1、 redis 是什么？都有哪些使用场景？
    redis是内存数据库，所有数据都放在内存。并可选择持久化。
    高速缓存（数据常驻内存）。
    消息队列（队列list）。
    分布式会话（保存session）。
    分布式锁（全局id，减库存、秒杀等）。
    计数器（浏览量、播放量等。可减轻数据库压力，使用incr加1，内存操作，性能好）。
    排行榜（浏览排行榜、销售排行榜等。redis提供有序集合数据类能实现各种复杂的排行榜应用）

2、redis 有哪些功能？

3、redis 和 memecache 有什么区别？
    1) redis支持的数据类型更多（string、hash、list、sort、sorted set）。
    2) redis 可持久化，而 memecache 不能
    3) 两者都是内存数据库

4、redis 为什么是单线程的？
    1) redis 是基于内存的操作，CPU不是瓶颈。
       Redis的瓶颈最有可能是内存和宽带。既然单线程容易实现，而且CPU不会成为瓶颈，那么顺理成章地采用单线程的方案。
    2) 不需要各种锁的性能消耗。
       Redis的数据结构并不全是简单的k-v，还有lish、hash等复杂的结构，这些结构可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加
       或者删除一个对象，这些操作可能就需要加非常多的锁，导致同步开销大大增加。
       在单线程的情况下，就不用考虑各种锁的问题，不存在加锁释放的操作，没有因为可能出现死锁而导致的性能消耗。
    3) 单线程多进程集群方案
       多线程的自然比单线程有更高的性能上限，但是在今天的计算环境，即时单机多线程的上限也往往不能满足需要了，单线程多进程的集群方案中多线程的技术用不上。
    4) CPU消耗
       采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多线程导致的切换而消耗CPU。
       如果CPU成为瓶颈，或不想让其他CPU闲置，可考虑多起几个Redis进程。
    Redis采用网络IO多路复用技术来保证在多连接的时候系统的高吞吐量。尽量减少网络IO的时间消耗。


5、什么是缓存穿透、缓存击穿、缓存雪崩？怎么解决？
    缓存击穿：
        描述：数据库和缓存中都没有数据。由于大量并发用户没有读到缓存，而去数据库取数据，引起数据库压力瞬间增大。
        解决方案：只允许一个用户去数据库取数据。

    缓存穿透：
        描述：数据库有数据，缓存中没有数据。而用户不断发起请求，比如id为-1的数据。
        解决方案：加校验。布隆过滤器。
                google的guava包中提供了BloomFilter类
                <dependencies>
                    <dependency>
                        <groupId>com.google.guava</groupId>
                        <artifactId>guava</artifactId>
                        <version>22.0</version>
                    </dependency>
                </dependencies>
    缓存雪崩：
        描述：大量缓存到期。
        解决方案：将过期时间设置在时间段上。

6、redis支持的数据类型？
    string:
        set key value
        get key
        incr key
        decr key
        setex key seconds value
        psetex key millseconds value

    hash:
        hget key field 获取存储在哈希表中指定字段的值
        hgetall key 获取在哈希表中指定key的所有字段和值
        hset key field value
    list:
        lpop key 移除并获取列表的第一个元素
        lpush key value1 value2 讲一个或多个值插入到列表头部
    set：
        sadd key mem1 mem2 
        scard key 获取集合的成员数
        smembers key 返回集合中的所有成员
        sdiff key1 key2 差集
        sinter key1 key2 交集
        sunion key2 key2 并集
    sorted set：
        zadd key score1 mem1 mem2
        zcard key

7、redis支持哪些java客户端？
    现有的java客户端：Jedis、Redission
    Jedis: 
        Jedis提供了JedisPool作为Jedis的连接池。
        Jedis单实例不是线程安全的，Jedis的请求流和响应流都是全局变量，是共享的，当不同的线程在set和get的时候，有可能出现线程A的set响应流，被线程B的get作为响应返回。
        为什么单实例是单线程而不是多线程？
        因为redis是单线程，一个实例使用一个线程和使用100个线程去发送命令没有本质的区别，所以没必要设置线程安全。
        连接池是线程安全的，因为连接池使用了多实例。
    Redission:

8、怎么保证缓存和数据库数据的一致性？
    无论是先写DB还是先写缓存，其本质是分布式事务。

9、Redis的持久化方式？
    快照RDB和AOF日志。
    快照是全量备份，AOF是增量备份；快照是二进制紧凑的文件，AOF是指令文本。
    
    快照原理
    Redis在持久化的时候会fork一个子进程，快照持久化完全交给子进程来处理，父线程继续处理客户端请求。
    子线程和父线程共享内存里面的代码和数据段。
    COW(copy on write)只有修改了数据，父线程才会将该数据页复制出一份，然后进行修改。这时子线程相应
    的页面是没有变化的，还是进程产生一瞬间的数据。随着父线程修改操作的持续进行，越来越多的共享页面被
    分离开来，内存会持续增长，但不会超过原来数据内存的2倍大小。

    AOF原理
    AOF日志存储的是Redis服务器的顺序指令序列，AOF日志只记录对内存进行修改的指令记录。
    Redis会在收到客户端修改指令后，先参数校验，然后立即存储到AOF日志，即先存磁盘，再执行指令。
    Redis在长期运行的过程中，AOF日志越来越长，重放会非常耗时。所以要对AOF日志瘦身。

    AOF重写
    bgrewriteaof指令可以对AOF日志进行瘦身。
    开辟一个子进程对内存进行遍历转换成一系列Redis的操作指令，序列化到一个新的AOF日志文件中。
    序列化完毕后再将操作期间发生的增量AOF日志追加到这个新的AOF日志文件中，追加完毕后就立即替代
    旧AOF日志文件了。

    fsync
    AOF日志以文件的形式存在。写AOF日志文件时，异步刷新保存到磁盘。
    Linux的glibc提供的fsync(int fd)函数可以将指定文件的内容强制从内核缓存刷新到磁盘。
    fsync是一个磁盘IO操作，很慢。
    生产环境中，Redis通常是每隔1s左右执行一次fsync操作，周期可以配置。
    还有另外两种策略：1、永不fsync(让操作系统来决定合适同步磁盘)；2、来一个指令就fsync(非常慢)。

    运维
    快照是通过开启子进程的方式进行的，它是一个比较耗资源的操作。
    1、遍历整个内存，大块写磁盘会加重系统负载
    2、AOF的fsync是一个耗时的IO操作，它会降低Redis性能，同时也会增加系统IO负担。
    所以通常Redis的主节点是不会进行持久化操作，持久化操作主要在从节点进行。

    Redis 4.0 混合持久化
    重启Redis时，很少使用rdb来恢复内存状态，因为会丢失大量数据。
    通常使用AOF日志重放，但是重放AOF日志性能相对rdb来说要慢的多。
    Redis 4.0 加入了新的持久化选项--混合持久化。将rdb文件的内存和增量的AOF日志文件存在一起。
    这里AOF日志不再是全量的日志，而是来自持久化开始到持久化结束的这段时间发生的增量AOF日志，
    通常这部分AOF日志很小。

10、Redis主从key不一致有哪些原因？
    1、主从内存限制是否一致。
    2、复制通道是否有延迟。
    3、过期key问题（可scan 0 count N清除过期key）。

11、Redis 常见的性能问题有哪些？该如何解决？
    1、主从复制性能问题，为了主从复制的速度和连接的稳定性，slave和master最好在一个局域网内。
    2、AOF文件过大会影响master重启时的恢复速度。
    3、AOF是一个耗时的IO操作，会增加系统的负担，master最好不要做任何持久化工作，slave持久化。
    4、调用bgrewriteaof重写AOF文件，会占用大量的CPU和内存资源。

12、Redis 淘汰策略？
    noeviction：不能继续写，删和读请求可以继续进行。这样可以保证数据不会丢失，但会让业务不能持续进行。默认淘汰策略。
    volatile-lru：尝试淘汰设置了过期时间的key，最少使用的key优先被淘汰。没有设置过期时间的key不会被淘汰。这样可以保证需要持久化的数据不会突然消失。
    volatile-ttl：尝试淘汰设置了过期时间的key，ttl最小的key优先被淘汰。
    volatile-random：尝试淘汰设置了过期时间的key，淘汰过期key集合中的随机key。
    allkeys-lru：淘汰对象是全部的key，最少使用的key优先淘汰。
    allkeys-random：淘汰对象是全部的key，随机key。

13、Redis 过期策略？
    被动删除：访问key的时候删除。
    主动删除：定时扫描设置了过期时间的key。
    从库：从库不进行主动扫描，被动接受同步过来的指令，指令同步是异步的，主从会出现不一致。
    懒惰删除：
        redis 4.0之前删除大对象key(包含了大量元素的hash)，则会导致单线程卡顿。
        redis 4.0之后，引入了unlink，丢给后台进程异步回收内存。
        flushdb、flushall可被flushall async和flushall async替代。
        同步AOF日志到磁盘，在异步线程中完成，独立的异步线程，和懒惰删除线程不是同一个
    设置过期：
        string中有setex 和 psetex
        顶级key有expire key seconds

14、Redis 如何做内存优化？
15、redis怎么实现分布式锁？
15、Redis分布式锁有什么缺陷？
16、Reids 的主从复制机制原理
    1）复制过程
        从节点执行slaveof命令；
        连接建立、权限验证；
        主节点将所有数据全部发给从节点（RDB文件且异步）；
        主节点会持续的把写命令发送给从节点。
    2）主从节点各自偏移量
        主从节点会维护自身的复制偏移量；
        主从节点各自的偏移量信息保存，info replication可以查看；
        从节点会每秒上报自身的复制偏移量给主节点，因此主节点也会保存从节点的复制偏移量。

17、Redis的线程模型是什么？

18、当前redis集群有哪些玩法，各自优缺点，场景？

19、Redis的并发竞争问题如何解决，了解Redis事务的CAS操作吗？
    两个连接同时对price进行写操作，同时加10，结果应该是30。但如果读数据和写数据分两步则会出现错误。
    解决方案：
        1）代码中加锁
        2）使用redis的乐观锁watch
            watch price
            get price $price
            $price = $price + 10
            multi
            set price $price
            exec
           watch用于监控price，如果执行exec的时候，key对应的值变化了，则事务不会执行。
           watch没有ABA问题。
        3）使用redis自带的incr命令
            incr、decr、incrby、decrby 它们是原子性递增或递减操作。
        4）使用setnx命令
            setnx只在key不存在的情况下，将键key的值设置为value。
            成功返回1，失败返回0。
            所以可以使用setnx实现锁。

20、Redis一致性hash？
    一般分布数据的算法：数据取模分布到相应的节点上，如果增加或删除或删除节点，数据很大部分会重新分布。
    一致性hash算法：环形hash空间，0~2^32-1节点范围，计算hash到key_N上，然后顺时针查找下一个数据节点，如果增加节点或删除节点也只会影响两个节点。

21、如何利用Redis处理热点数据？
    限制内存+内存淘汰策略。

22、Redis哨兵？
    哨兵模式：主服务器宕机后，可以自动将一台从服务器切换为主服务器。
    哨兵作用：
        1）通过发送命令，让Redis服务器返回其运行状态。
        2）监控到master宕机，会自动将slave切换到master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。
    多哨兵：一个哨兵可能会出现问题。
            多个哨兵监控Redis服务器，只有当多个哨兵监控到master不可用的时候，才会进行投票，投票决定是否切换主从。
            https://www.jianshu.com/p/06ab9daf921d

23、谈谈Redis哨兵、复制、集群工作中技术优化过哪些？
24、redis集群搭建，高可用，原理？
25、redis底层实现，redis是如何更新缓存的？
26、为什么使用redis做缓存而不是其他的消息队列入kafka，以及项目的稳定性？
27、mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？
    限定Redis占用的内存，Redis会根据自身数据淘汰策略。

28、用Redis和任意语言实现一段恶意登录保护的代码，限制1小时内每用户Id最多只能登录5次
    每次登录记录下来，设置过期时间为1小时。登录的时候取出所有的登录记录，记录数小于等于4则允许登录，否则禁止。

29、Redis批量导入数据？
    pipeline命令
    pipeline指的是管道技术，指的是客户端允许将多个请求依次发给服务器，过程中不需要等待请求的回复，在最后再一并读取结果。



