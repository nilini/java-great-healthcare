>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring<<<<<<<<<<<<<<<<<<<<<<<<<<<<,
对Spring的理解，项目中都用什么？怎么用的？
    用到了spring的aop

什么是Spring声明式事务，如何配置？
    声明式事务管理式建立在AOP之上的，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。
    优点是不需要通过编程的方式管理事务。 
@Transactional注解一般写在什么位置?如何控制其回滚?
    1、基于tx和aop名字空间的xml配置文件：
        <!-- 对数据源进行事务管理 -->
        <bean id="transactionManager"
            class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
            <property name="dataSource" ref="dynamicDataSource" />
        </bean>
        
        <!-- 配置哪些方法要加入事务控制 -->
        <tx:advice id="txAdvice" transaction-manager="transactionManager">
            <tx:attributes>
                <!-- 让所有的方法都加入事务管理，为了提高效率，可以把一些查询之类的方法设置为只读的事务 -->
                <tx:method name="*" propagation="REQUIRED" read-only="true" />
                <!-- 以下方法都是可能设计修改的方法，就无法设置为只读 -->
                <tx:method name="add*" propagation="REQUIRED" rollback-for="java.lang.Exception"/>
                <tx:method name="insert*" propagation="REQUIRED" />
                <tx:method name="del*" propagation="REQUIRED" />
                <tx:method name="update*" propagation="REQUIRED" />
                <tx:method name="save*" propagation="REQUIRED" />
                <tx:method name="clear*" propagation="REQUIRED" />
                <tx:method name="handle*" propagation="REQUIRED" rollback-for="java.lang.Exception"/>
            </tx:attributes>
        </tx:advice>
        
        <!-- 配置一个切面 -->
        <aop:config>
            <!-- 配置一个切点 -->
            <aop:pointcut id="allMethods" expression="(execution(* cn.edu.his.pay.service.*.*(..)))" />
            <aop:advisor advice-ref="txAdvice" pointcut-ref="allMethods" />
        </aop:config>
        
    2、基于@Transactional注解，核心配置如下：
        <!-- 对数据源进行事务管理 -->
        <bean id="transactionManager"
            class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
            <property name="dataSource" ref="dynamicDataSource" />
        </bean>
        
        <!-- 开启事务控制的注解支持 -->
        <tx:annotation-driven transaction-manager="transactionManager"/>

    总结：二种方式都能有效利用Spring的事务管理机制来管理事务的ACID，这里在项目中要使用那种方式还需要一定的取舍；首先我们来分析第一种，第一种主要是采用Aop+xml的配置，这种方式主要是在xml中配置Aop的切入点（就是service中的方法）和配置哪些方法需要加入事务管理，通常用正则匹配的方式，且核心的配置信息（事务控制）都是配置在xml中；而第二种是Aop+annotation的，这种方式是利用Aop去扫描带@Transactional的注解的方法，并在该方法之前按照注解配置的事务控制规则来进行事务的管理。当业务中出现需要批量的设置方法的事务控制规则的时候推荐使用第一种，反之都选择选择第二种，而第二种是需要在每个需要事务控制的方法上都加入注解，但由于第一种控制的是所有方法，第二种是控制的指定方法，这个时候第一种的开销肯定要比第二种大，还有就是需要了解事务隔离级别，要考虑在指定业务上要怎么能保证数据的ACID，这样才能在代码中更好的设置对应的事务控制规则，还有就是千万不要在同一个项目中使用了带二种方式的事务配置（没意义），它们功能是一样的，使用一种就行。

21，SpringAOP，XML配置<aop:config>，切面<aop:aspect>切点<aop:pointcut>，连接切点和通知方法<aop:before>和<aop:after>等，
    注解可以直接使用@before执行方法@after ，@before(“pointcut()”) ，@after("pointcut")， @Aroud("excutete())，@AfteReturning，@AfterThrowing，
    可作日志事务，权限等待，AOP即通过把具体的类创建对应的 代理类，从代理类来对具体进行操作。                      
    目标实现了接口，默认采用JDK实现AOP，也可以强制使用CGlib来实现AOP，目标没有实现接口的话，则必须采用CGlib，Spring自动在JDK和CGlib切换。
    如果要求spring强制使用CGlib实现AOP，则可以配置，添加Cglib库。。。jar， Spring配置文件中加入<aop:aspecj-autoproxy proxy-target-Class=true>                                                                                                                                                                                   

70.spring mvc 和 struts 的区别是什么？ 
    struts2是基于类的拦截。每次处理一个请求，struts就会实例化一个对象，这样就不会有线程安全的问题了。
    spring mvc是方法级别的拦截，一个方法对应一个Request上下文，所以方法基本上是独立的，独享request，response数据。
    而每个方法同时又和一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。
    处理结果通过ModelMap返回给框架。Spring的controller默认是Singleton的，这意味着每一个request过来，
    系统都会用原有的instance去处理。

    为应对线程安全问题，尽量避免在controller中定义实例变量。如果非要用到实例变量：
    1）在controller中使用ThreadLocal变量
    2）在spring配置文件controller中声明scope = "prototype"，每次都创建新的controller。
    3）不修改变量，只调用方法就不会有线程安全问题。比如注入service，虽然service并不是线程安全的，但是只会调用service中的方法。

90.为什么要使用 spring？
    spring是个大工厂，可以将所有对象创建和依赖关系维护，交给spring管理。不用手动创建对象。
    通过代码解耦，提高代码灵活性（依赖注入 DI）
    简化开发，用最少的代码，做最多的事情（AOP，Template）
    提供公共抽象，屏蔽底层，开箱即用，替换方便（Spring Cache，框架，中间件集成）
    MVC模型的快速实现（视图解析，数据转换）

91.解释一下什么是 aop？
    切面、切点、连接切点、通知方法
    Spring Aop是使用动态代理来实现的。基于JDK的动态代理和基于Cglib的代理。
    aop是面向切面编程。通过动态代理实现程序功能的统一维护。
    好处：
        1）集中处理某一关注电/横切逻辑
        2）可以很方便地添加/删除关注点
        3）侵入性少，增强代码可读性及可维护性
    spring中的使用：
        Aspect：切面，是一个类，里面定义了通知和切点。
        PointCut：切点。
        advice：通知。
            @Before：前置通知，在调用目标方法之前执行通知定义的任务。
            @After：目标方法调用之后执行。不管成功与否。
            @After-returning：目标方法执行结束，且成功时候调用。
            @After-throwing：异常通知，目标方法执行过程中发生异常，则执行通知定义的任务。
            @Around：环绕通知，在目标方法执行前后，都需要执行通知定义的任务。
    切面表达式：execution (* com.sample.service.impl..*.*(..))
               第一个*：返回类型，表示所有的类型。
               com.sample.service.impl..：表示该路径下的包及子包。
               第二个*：所有类。
               第三个*：所有方法。
               (..)：表示方法的参数。两个点表示任何参数。
    /**
    * 系统服务组件Aspect切面Bean
    * @author Shenghany
    * @date 2013-5-28
    */
    @Component   //声明这是一个组件
    @Aspect      //声明这是一个切面Bean
    @Order(3)    //定义切面执行顺序
    public class ServiceAspect {
        private final static Log log = LogFactory.getLog(ServiceAspect.class);
        
        //配置切入点,该方法无方法体,主要为方便同类中其他方法使用此处配置的切入点
        @Pointcut("execution(* cn.ysh.studio.spring.aop.service..*(..))")
        public void aspect(){	

        }
        /*
        * 配置前置通知,使用在方法aspect()上注册的切入点
        * 同时接受JoinPoint切入点对象,可以没有该参数
        */
        @Before("aspect()")
        public void before(JoinPoint joinPoint){
            if(log.isInfoEnabled()){
                log.info("before " + joinPoint);
            }
        }
        //配置后置通知,使用在方法aspect()上注册的切入点
        @After("aspect()")
        public void after(JoinPoint joinPoint){
            if(log.isInfoEnabled()){
                log.info("after " + joinPoint);
            }
        }
        //配置环绕通知,使用在方法aspect()上注册的切入点
        @Around("aspect()")
        public void around(JoinPoint joinPoint){
            long start = System.currentTimeMillis();
            try {
                ((ProceedingJoinPoint) joinPoint).proceed();
                long end = System.currentTimeMillis();
                if(log.isInfoEnabled()){
                    log.info("around " + joinPoint + "\tUse time : " + (end - start) + " ms!");
                }
            } catch (Throwable e) {
                long end = System.currentTimeMillis();
                if(log.isInfoEnabled()){
                    log.info("around " + joinPoint + "\tUse time : " + (end - start) + " ms with exception : " + e.getMessage());
                }
            }
        }
        //配置后置返回通知,使用在方法aspect()上注册的切入点
        @AfterReturning("aspect()")
        public void afterReturn(JoinPoint joinPoint){
            if(log.isInfoEnabled()){
                log.info("afterReturn " + joinPoint);
            }
        }
        
        //配置抛出异常后通知,使用在方法aspect()上注册的切入点
        @AfterThrowing(pointcut="aspect()", throwing="ex")
        public void afterThrow(JoinPoint joinPoint, Exception ex){
            if(log.isInfoEnabled()){
                log.info("afterThrow " + joinPoint + "\t" + ex.getMessage());
            }
        }
        
    }
92.解释一下什么是 ioc？

93.spring 有哪些主要模块？
    Spring Core：提供IOC
    Spring Context：
    Spring DAO：提供了JDBC的抽象层，可以消除冗长的JDBC编码和解析数据库厂商特有的错误代码。还提供了一种比编程性更好的声明性事务管理方法。
    Spring ORM：
    Spring AOP：
    Spring Web：提供了基础的针对Web开发的继承特性，例如多文件上传。
    Spring Web MVC：提供了Web应用中的MVC实现。
94.spring 常用的注入方式有哪些？
    1）构造方法
    2）setter方法
    3）基于注解的注入
        四种注解可以注入bean：
            @Component 可用于注入所有bean
            @Repository 主要用于注入dao层的bean
            @Controlelr 主要用于注入控制层的bean
            @Service    主要用于注入服务层的bean
        
95.spring 中的 bean 是线程安全的吗？
    原型bean，每次创建一个新对象，也就是线程之间并不存在bean共享，自然是不会有线程安全的问题。
    单例bean，所有线程都共享一个实例bean，因此存在资源的竞争。如果单例bean是一个无状态的bean，比如controller、service、dao。这些bean
    大多是无状态的，只关注于方法本身。
    对于有状态的bean，spring官方提供的bean，一般提供了通过ThreadLocal去解决线程安全的方法。比如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等。
96.spring 支持几种 bean 的作用域？
    单例（singleton）：默认作用域。
    原型（prototype）：原型，每次创建一个新对象。
    请求（request）：每次http请求创建一个新对象，适用于WebApplicationContext环境下。
    会话（session）：同一个会话共享一个实例，不同会话使用不同的实例。
    全局会话（global-session）：所有会话共享一个实例。 
97.spring 自动装配 bean 有哪些方式？
    @Resource
    @Autowired

99.说一下 spring 的事务隔离？
    定义了五种表示事务隔离界别的常量：
    1）TransactionDefinition.ISOLATION_DEFAULT：使用后端数据库默认的隔离界别，MySQL默认采用的REPEATABLE_READ隔离级别，Oracle默认采用的READ_COMMITTED隔离级别。
    2）TransactionDefinition.ISOLATION_READ_UNCOMMITTED：读未提交
    3）TransactionDefinition.ISOLATION_READ_COMMITTED：读已提交
    4）TransactionDefinition.ISOLATION_REPEATABLE_READ：可重复读
    5）TransactionDefinition.ISOLATION_SERIALIZABLE：序列化。事务串行化执行。
    七种事务传播（事务传播行为是Spring提供的一种事务管理方式，它不是数据库提供的）
    1）PROPAGATION_REQUIRED : 如果存在事务，加入当前事务；如果不存在，就新建一个事务。
    2）PROPAGATION_SUPPORTS : 如果存在事务，加入当前事务；如果不存在，则非事务执行。
    3）PROPAGATION_MANDATORY : 如果存在事务，加入当前事务；如果不存在，抛出异常（只能作为事务执行）。
    4）PROPAGATION_REQUIRES_NEW : 如果有事务存在，则挂起当前事务，创建一个新的事务（两个事务没有关系）；如果不存在，则创建一个新事务。
    5）PROPAGATION_NOT_SUPPORTED : 以非事务方式运行，如果有事务存在，挂起当前事务（非事务和外层事务没有关系）。
    6）PROPAGATION_NEVER : 以非事务运行，如果有事务存在，抛出异常（只能作为非事务执行）。
    7）PROPAGATION_NESTED : 如果不存在事务，则作为开启新事物；如果当前事务存在，则嵌套事务执行（外层事务失败，会回滚内层事务所做的动作；内层事务失败不影响外层事务的回滚）。
    https://blog.csdn.net/weixin_39625809/article/details/80707695
103.@Autowired 的作用是什么？
    @Autowired和@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。
    @Autowired默认按类型装配。可和@Qualifier一起使用按名称装配:@Autowired() @Qualifier("baseDao")
    @Resource默认按名称进行装配。名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名。
51.ThreadLocal 是什么？有哪些使用场景？
    ThreadLocal类可以让创建的变量只被同一个线程进行读和写操作。因此，尽管两个线程同时执行一段相同的代码，而且
    这段代码又有一个指向同一个ThreadLocal变量的引用，但是着两个线程依然不能看到彼此的ThreadLocal变量域。

    ThreadLocal为每个线程创建了一个副本。
    Spring使用ThreadLocal解决线程安全问题，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大多数Bean都可以
    声明为singleton作用域。Spring通过ThreadLocal解决Bean的线程安全问题。

讲讲Spring加载流程。
    Spring核心组件：
        Core、Context、Beans三个。
        Core：
            包含了很多关键类，其中一个重要组成部分就是定义了资源的访问方式，把所有资源都抽象成一个接口。
            对于资源使用者来说，不需要考虑文件的类型。对资源提供者来说，也不需要考虑如何将资源包装起来交给别人使用。
        Context：
            Context组件的作用是给Spring提供一个运行时的环境，用以保存各个对象的状态。
            ApplicationContext 是 Context 的顶级父类，他除了能标识一个应用环境的基本信息外，他还继承了五个接口，这五个接口主要是扩展了 Context 的功能。
        Bean：
            Bean组件在Spring的org.springframework.beans包下，主要完成了Bean的创建、定义以及Bean的解析。
            SpringBean的创建是典型的工厂模式，最终默认实现类是DefaultListableBeanFactory，实现了所有的接口。
            Bean的定义主要在BeanDefinition描述，其完整的描述了在Spring配置文件中定义的<bean/>节点的所有信息，包括子节点。
            当一个<Bean/>节点被成功解析之后，在Spring内部会被转化成一个BeanDefinition对象，接下来的所有操作都是对这个对象进行的。
            Bean的解析主要是对Spring配置文件的解析。
    https://blog.csdn.net/wzk646795873/article/details/79764870

说说你对Spring的理解，非单例注入的原理？它的生命周期？循环注入的原理，aop的实现原理，说说aop中的几个术语，它们是怎么相互工作的。

自己有没有写过类似Spring这样的AOP事务？

Spring AOP IOC的实现原理，底层用什么实现的？

spring框架中需要引用哪些jar包，以及这些jar包的用途
1）spring-core.jar：包含spring框架基本的核心工具类，其他组件都要使用这个包里面的类，是其他组件的核心；
  2）spring-bean.jar：是所有的应用都要用到的，包含访问配置文件、创建和管理bean以及进行IoC和DI操作所需的相关类；
  3）spring-aop.jar：包含使用AOP特性时所需的类；
  4）spring-context.jar：为spring核心提供了大量扩展；
  5）spring-dao.jar：包含spring DAO、spring Transaction进行数据访问的所有类；
  6）spring-hibernate.jar：包含spring对hibernate 2以及hibernate 3进行封装的所有类；
  7）spring-jdbc.jar：包含spring对JDBC数据库访问进行封装的所有类；
  8）spring-orm.jar：包含多DAO特性集进行了扩展；
  9）spring-remoting.jar：包含支持EJB、JMS、远程调用Remoting方面的类；
  10）spring-support.jar：包含支持缓存Cache、JAC、JMX、邮件服务、任务计划Scheduling方面的类；
  11）spring-web.jar：包含web开发时，用到spring框架时所需的核心类；
  12）spring-webmvc.jar：baohan Spring MVC框架相关的所有类；
  13）spring-mock.jar：包含spring一整套mock类来辅助应用的测试。

spring中beanFactory和ApplicationContext的联系和区别
    Spring容器最基本的接口就是BeanFactory。BeanFactory负责配置、创建、管理Bean，它有一个子接口ApplicationContext，也被称为Spring上下文，容器同时还管理着Bean和Bean之间的依赖关系。
    ApplicationContext除了提供上述BeanFactory所提供的功能之外，还提供了更完整的其他功能：
        a、国际化支持 
        b、资源访问 Resource rs = ctx. getResource(“classpath:config.properties”),
        c、事件传递

spring加载bean的流程？
    1）获取配置文件
        ClassPathResource res = new ClassPathResource("applicationContext.xml");
        加载XML文件，封装成Resource对象
    2）解析配置文件并注册Bean
        XmlBeanFactory bf = new XmlBeanFactory(res);
        将applicationContext.xml配置的Bean信息构成BeanDefinition对象，然后放到Factory的map中（注册）。
    3）实例化Bean
        MyBean bean = (MyBean)bf.getBean("myBean");
        基本原理是利用反射机制，通过bean的class属性创建一个bean的实例。
    4）调用对象的方法

spring的事务怎么使用？事务回滚？自定义异常？

spring中循环注入的方式

5.Spring的一些机制理解？IOc？AOP？IOc如何实现依赖注入的？Spring动态代理的实现方式？

Spring的beanFactory和factoryBean的区别

Spring的事务隔离级别，实现原理

对Spring的理解，非单例注入的原理？它的生命周期？循环注入的原理，aop的实现原理，说说aop中的几个术语，它们是怎么相互工作的？

拦截器和Intercepter？

Spring中常用注解？

Spring中如果一个注入一个对象，但是这个对象有多个实例，怎么处理？

2、什么是基于注解的切面实现
    1) 什么是AOP？
    在程序运行时，动态的将代码切入到类的指定方法、指定位置上的编程思想就是面向切面编程。
    AOP是OOP的补充，OOP从横向上区分出一个个类来，而AOP则是从纵向上对对象加入特定的代码。
    为多个不具有继承关系的对象引入一个公共行为，例如日志、权限验证、事务等功能时，只能在在每个对象
    里引入公共行为。这样做不便于维护，而且有大量重复代码。
    2) 实现AOP的两种方式
        原生JDK，代理类只需要实现InvocationHandler接口。
        另一个是cglib。
    3) Spring AOP 框架对 AOP 代理类的处理原则是
        如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；
        如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类——
        不过这个选择过程对开发者完全透明、开发者也无需关心。
Spring中bean的生命周期

Spring的启动、加载过程？

Spring中什么是Lazy-Load？

Spring中Bean有哪些Scope？

Spring如何解决循环依赖？
    循环依赖就是循环引用，两个或多个bean相互持有对方。
    1）构造器循环依赖：
        表示通过构造器注入构成的循环依赖，此依赖是无法解决的。只能抛出BeanCurrentlyInCreationException异常表示循环依赖。
        Spring容器将每一个正在创建的Bean标识符放在一个 “当前创建Bean池” 中。Bean标识符在创建过程中将一直保持在这个池中，
        因此如果在创建Bean过程中发现自己已经在 “当前创建Bean池” 里时将抛出BeanCurrentlyInCreationException异常表示循环依赖，
        对于创建完毕的Bean将从 “当前创建Bean池” 中清除掉。
    2）setter循环依赖：
        表示通过setter注入方式构成的循环依赖。
        https://www.cnblogs.com/mxmbk/articles/5371676.html

6、Spring AOP中代理选择
    1) 如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP。
    2) 如果目标对象实现了接口，也是可以强制使用cglib实现AOP。
    3) 如果目标对象没有实现接口，则会使用cglib。
    通过@EnableAspectJAutoProxy(proxyTargetClass = true)

8、Spring AOP用到了动态代理；
   Spring 事务管理用到了动态代理；
   MyBatis数据库连接池用到了动态代理；
   MyBatis创建Mapper用到了动态代理。

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>spring mvc<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<,,
1、SpringMVC常用的注解，RequestBody，ResponseBody ，RequestParam，PathVariables，RestController，ControllerAdvice， WebInitParam，InitBinder

2、SpringMVC如何做类型转换？
    Converter可以将一种类型转换为另一种类型。例如，将String转换成Date，或者将Long转化成Date。
    步骤：
        1）实现 Converter 接口
            public class DateConverter implements Converter<String, Date> {
                /**
                * 将 yyyy-MM-dd 格式的字符串转换成日期对象
                */
                @Override
                public Date convert(String dateStr) {
                    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
                    Date date = null;
                    try {
                        date = sdf.parse(dateStr);
                    } catch (ParseException e) {
                        e.printStackTrace();
                    }
                    return date;
                }
            }
        2）Spring MVC的配置文件中配置一个ConversionServiceFactoryBean
            <!--开启mvc注解驱动  -->
            <mvc:annotation-driven conversion-service="conversionService" />
            <!-- 注册自定义的类型转换器 -->
            <bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean">
                <property name="converters">
                    <list>
                        <bean class="com.qjl.pems.converter.DateConverter"></bean>
                    </list>
                </property>
            </bean>
    spring boot中直接使用@Component修饰自定义的转换类。

3、SpringMVC如何做参数校验？
        @Valid 
            是使用hibernate validation 校验使用。hibernate-validator实现了jsr 303规范。
        @Validated 
            是只用Spring Validator 校验使用。
        https://www.cnblogs.com/myinspire/articles/7649027.html
4、srpingMVC的原理
5、springMVC注解的意思
34，SpirngMVC的生命周期 和 SpringBean的生命周期
    SpirngMVC的生命周期 ：
    A，DispatcherSerlvet（前端控制器）
    B，-》 HandlerMapping（处理器映射器），根据xml注解查找对应的Hander -》 返回Handler
    C，-》处理器适配器去执行Handler
    D，-》Handler执行完成后给处理器适配器返回ModelAndView
    E，-》前端控制器请求视图解析器去执行视图解析，根据逻辑视图名解析成真正的视图JSP，向前端控制器返回view
    F，-》前端控制器进行视图渲染，将模型数据放到request-》返回给用户

    SpringBean的生命周期：
    Instance实例化-》设置属性值-》调用BeanNameAware的setBeanName方法-》调用BeanPostProsessor的预初始化方法-》调用InitializationBean的afterPropertiesSet()的方法-》调用定制的初始化方法callCustom的init-method-》调用BeanPostProsessor的后初始化方法-》Bean可以使用了 -》 容器关闭-》 调用DisposableBean的destroy方法-》调用定制的销毁方法CallCustom的destroy-method。

springmvc用到的注解，作用是什么，原理。
Springmvc 中DispatcherServlet初始化过程。
100.说一下 spring mvc 运行流程？
    https://www.cnblogs.com/gxc6/p/9544563.html
    DispatcherServer：配置在web.xml中，拦截请求，自己定义拦截规则。
    HandlerMapping：解析请求链接，然后根据请求链接找到执行这个请求的类（handler，即Controller）。找到handler之后封装成一个HandlerExecutionChain对象（包含Controller和一组拦截器）。

    一个请求匹配前端控制器 DispatcherServlet 的请求映射路径(在 web.xml中指定), WEB 容器将该请求转交给 DispatcherServlet 处理
    DispatcherServlet 接收到请求后, 将根据 请求信息 交给 处理器映射器 （HandlerMapping）
    HandlerMapping 根据用户的url请求 查找匹配该url的 Handler，并返回一个执行链
    DispatcherServlet 再请求 处理器适配器(HandlerAdapter) 调用相应的 Handler 进行处理并返回 ModelAndView 给 DispatcherServlet
    DispatcherServlet 将 ModelAndView 请求 ViewReslover（视图解析器）解析，返回具体 View
    DispatcherServlet 对 View 进行渲染视图（即将模型数据填充至视图中）
    DispatcherServlet 将页面响应给用户

101.spring mvc 有哪些组件？
    1）HandlerMapping 处理器映射器
        通过处理器映射，可以将web请求映射到正确的处理器Controller上，当接收到请求时，DispatcherServlet将请求交给HandlerMapping处理器映射，
        让它检查请求并找到一个合适（Controller类）HadnlerExecutionChain，这个HadnlerExecutionChain包含一个能处理该请求的处理器Controller。
        默认情况下，如果没有在上下文中找到处理器映射，DispatcherServlet会为你创建一个BeanNameUrlHandlerMapping。
    2）Controller 处理器
        处理请求。
    3）ViewResolver 试图解析器
        解析返回的ModelAndView，选择一个合适的ViewResolver（必须是已经注册到Spring容器中的ViewResolver）返回给DispatcherServlet。
        ViewResolver结合Model和View，来渲染试图，将渲染结果返回给客户端。

102.@RequestMapping 的作用是什么？
    url和Controller方法之间的映射。
1、什么是Spring MVC ？简单介绍下你对springMVC的理解?

Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把Model，View，Controller分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。

2、SpringMVC的流程？

（1）用户发送请求至前端控制器DispatcherServlet；
（2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；
（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；
（4）DispatcherServlet 调用 HandlerAdapter处理器适配器；
（5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)；
（6）Handler执行完成返回ModelAndView；
（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；
（8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；
（9）ViewResolver解析后返回具体View；
（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）
（11）DispatcherServlet响应用户。



3、Springmvc的优点:

（1）可以支持各种视图技术,而不仅仅局限于JSP；
（2）与Spring框架集成（如IoC容器、AOP等）；
（3）清晰的角色分配：前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）。
（4）支持各种请求资源的映射策略。

 

4、Spring MVC的主要组件？

（1）前端控制器 DispatcherServlet（不需要程序员开发）

作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。

（2）处理器映射器HandlerMapping（不需要程序员开发）

作用：根据请求的URL来查找Handler

（3）处理器适配器HandlerAdapter

注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。

（4）处理器Handler（需要程序员开发）

（5）视图解析器 ViewResolver（不需要程序员开发）

作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）

（6）视图View（需要程序员开发jsp）

View是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）

 

5、springMVC和struts2的区别有哪些?

（1）springmvc的入口是一个servlet即前端控制器（DispatchServlet），而struts2入口是一个filter过虑器（StrutsPrepareAndExecuteFilter）。

（2）springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，
     struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。

（3）Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，
     springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。

 

6、SpringMVC怎么样设定重定向和转发的？

（1）转发：在返回值前面加"forward:"，譬如"forward:user.do?name=method4"

（2）重定向：在返回值前面加"redirect:"，譬如"redirect:http://www.baidu.com"

 

7、SpringMvc怎么和AJAX相互调用的？

通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。具体步骤如下 ：

（1）加入Jackson.jar

（2）在配置文件中配置json的映射

（3）在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解。

 

8、如何解决POST请求中文乱码问题，GET的又如何处理呢？

（1）解决post请求乱码问题：

在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；

<filter>

    <filter-name>CharacterEncodingFilter</filter-name>

    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>

    <init-param>

        <param-name>encoding</param-name>

        <param-value>utf-8</param-value>

    </init-param>

</filter>

<filter-mapping>

    <filter-name>CharacterEncodingFilter</filter-name>

    <url-pattern>/*</url-pattern>

</filter-mapping>

（2）get请求中文参数出现乱码解决方法有两个：

①修改tomcat配置文件添加编码与工程编码一致，如下：

<ConnectorURIEncoding="utf-8" connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443"/>

 ②另外一种方法对参数进行重新编码：

String userName = new String(request.getParamter("userName").getBytes("ISO8859-1"),"utf-8")

ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。

 

9、Spring MVC的异常处理 ？

答：可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。

10、SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？

答：默认是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。

11、 SpringMVC常用的注解有哪些？

@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。

@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。

@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。

12、SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代？

答：一般用@Conntroller注解,表示是表现层,不能用别的注解代替。

13、如果在拦截请求中，我想拦截get方式提交的方法,怎么配置？

答：可以在@RequestMapping注解里面加上method=RequestMethod.GET。

14、怎样在方法里面得到Request,或者Session？

答：直接在方法的形参中声明request,SpringMvc就自动把request对象传入。

15、如果想在拦截的方法里面得到从前台传入的参数,怎么得到？

答：直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。

16、如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？

答：直接在方法中声明这个对象,SpringMvc就自动会把属性赋值到这个对象里面。

17、SpringMvc中函数的返回值是什么？

答：返回值可以有很多类型,有String, ModelAndView。ModelAndView类把视图和数据都合并的一起的，但一般用String比较好。

18、SpringMvc用什么对象从后台向前台传递数据的？

答：通过ModelMap对象,可以在这个对象里面调用put方法,把对象加到里面,前台就可以通过el表达式拿到。

19、怎么样把ModelMap里面的数据放入Session里面？

答：可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key。

 

20、SpringMvc里面拦截器是怎么写的：

有两种写法,一种是实现HandlerInterceptor接口，另外一种是继承适配器类，接着在接口方法当中，实现处理逻辑；然后在SpringMvc的配置文件中配置拦截器即可：

  <!-- 配置SpringMvc的拦截器 -->
 
<mvc:interceptors>
 
    <!-- 配置一个拦截器的Bean就可以了 默认是对所有请求都拦截 -->
 
    <bean id="myInterceptor" class="com.zwp.action.MyHandlerInterceptor"></bean>
 
    <!-- 只针对部分请求拦截 -->
 
    <mvc:interceptor>
 
       <mvc:mapping path="/modelMap.do" />
 
       <bean class="com.zwp.action.MyHandlerInterceptorAdapter" />
 
    </mvc:interceptor>
 
</mvc:interceptors>
 

21、注解原理：
    注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。
    我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。
    通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。
    该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>spring boot<<<<<<<<<<<<<<<<<<<<<<<<<<

SpringBoot的优缺点？为什么使用它？工作原理？

SpringBoot中什么是profile？如何启用不同的profile？如何定义多套不同环境配置？

SpringBoot中EnableXxx注解是如何工作的

如何理解 Spring Boot 中的 Starters？

SpringBoot 实现热部署有哪几种方式？

如何理解 Spring Boot 配置加载顺序？
Spring Boot常用的注解
spring boot特性，优势，适用场景等
104.什么是 spring boot？

105.为什么要用 spring boot？

106.spring boot 核心配置文件是什么？

107.spring boot 配置文件有哪几种类型？它们有什么区别？

108.spring boot 有哪些方式可以实现热部署？
springboot启动机制。
50，SpringBoot的优点？
    答：
    快速构建项目，极大的提高了开发、部署效率。
    对主流开发框架的无配置集成。
    项目可独立运行，无须外部依赖Servlet容器。
    提供运行时的应用监控。

    简化编码：创建一个web项目时，使用spring时，需要在pom中添加多个依赖。而spring boot简化了依赖，只需要添加starter-web依赖即可。
    简化配置：spring的xml很繁琐，spring boot合并了一些注解。
    简化部署：spring时，要将项目打成war包扔到tomcat里；使用spring boot时，不去要部署tomcat，因为spring boot内嵌了tomcat，只需要将项目打成jar包，使用java -jar xxx.jar一键式启动项目。
    提供运行时监控：可以引入 spring-boot-start-actuator 依赖。直接使用rest方式来获取进程的运行期性能参数。
Spring、Springboot中如何做单元测试？

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>spring cloud<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
什么是Spring Cloud？SpringCloud 的优缺点？
什么是Hystrix
Spring Cloud用到什么东西？

110.什么是 spring cloud？

111.spring cloud 断路器的作用是什么？

112.spring cloud 的核心组件有哪些？
Spring Cloud的各个项目基于Spring Boot，将Netflix的多个框架进行封装，通过自动配置的方式将这些框架绑定到Spring环境中。
Eureka：基于REST服务的分布式中间件，主要用于服务管理（发现）。
Hystrix：容错框架，通过添加延迟阈值以及容错的逻辑，帮助我们控制分布式系统间组件的交互。
Feign：一个REST客户端，目的是为了简化Web Service客户端的开发。
Ribbon：负载均衡框架，在微服务集群中为各个客户端的通信提供支持，它只要实现中间层应用程序的负载均衡。
Zull：为微服务集群提供代理、过滤、路由等功能。
其他模块：
Spring Cloud Config：为分布式系统提供了配置服务器和配置客户端，通过对他们的配置，可以很好的管理集群中的配置文件。
Spring Cloud Sleuth：服务跟踪框架，可以与Zipkin、Apache HTrace和ELK等数据分析、服务跟踪系统进行整合，为服务跟踪、解决问题提供了便利。
Spring Cloud Strean：用于构建消息驱动微服务的框架，在Spring Boot的基础上，整合了Spring Integration来连接消息代理中间件。
Spring Cloud Bus：连接RabbitMQ、Kafka等消息代理的集群消息总线。
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Hibernate <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

109.jpa 和 hibernate 有什么区别？
    hibernate orm是jpa规范的一个实现。

113.为什么要使用 hibernate？

114.什么是 ORM 框架？

115.hibernate 中如何在控制台查看打印的 sql 语句？

116.hibernate 有几种查询方式？

117.hibernate 实体类可以被定义为 final 吗？

118.在 hibernate 中使用 Integer 和 int 做映射有什么区别？

119.hibernate 是如何工作的？

120.get()和 load()的区别？

121.说一下 hibernate 的缓存机制？

122.hibernate 对象有哪些状态？

123.在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？

124.hibernate 实体类必须要有无参构造函数吗？为什么？
11.Hibernate的缓存？各有什么作用？

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> mybatis <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
什么是ORM？如何写一个orm框架
    ORM：Object Relational Mapping。
    对象和数据库的映射。

Mybatis的工作机制
    1）读取MyBatis配置文件：mybatis-config.xml为mybatis的全局配置文件，配置了mybatis的运行环境等信息，例如数据库连接信息。
    2）加载映射文件。即sql映射文件，需要在mybatis-config.xml中加载，mybatis-config.xml可以配置多个映射文件，每个文件对相应数据库中的一张表。
    3）构造会话工厂：通过mybatis的环境等配置信息构建会话工厂SqlSessionFactory。
    4）创建会话对象：由会话工厂创建SqlSession对象，该对象中包含了执行sql语句的所有方法。
    5）Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。
    6）MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。
    7）输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程。
    8）输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程。

Mybatis中如何做分页？
    1）查询所有数据，然后数组中分页
    2）sql分页
        mybatis接口
        List<Student> queryStudentsBySql(Map<String,Object> data);
        
        xml文件
        <select id="queryStudentsBySql" parameterType="map" resultMap="studentmapper">
                select * from student limit #{currIndex} , #{pageSize}
        </select>
        service

        接口
        List<Student> queryStudentsBySql(int currPage, int pageSize);
        实现类
        public List<Student> queryStudentsBySql(int currPage, int pageSize) {
            Map<String, Object> data = new HashedMap();
            data.put("currIndex", (currPage-1)*pageSize);
            data.put("pageSize", pageSize);
            return studentMapper.queryStudentsBySql(data);
        }
    3）拦截器


Mybatis中如何自定义插件？
    Mybatis允许在已映射语句执行过程中的某一点进行拦截调用。允许拦截的方法调用：
    Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)
    ParameterHandler (getParameterObject, setParameters)
    ResultSetHandler (handleResultSets, handleOutputParameters)
    StatementHandler (prepare, parameterize, batch, update, query)
    
    拦截执行器的方法。
    拦截参数的处理。
    拦截结果集的处理。
    拦截sql语法构建的处理。

    Executor是 Mybatis的内部执行器，它负责调用StatementHandler操作数据库，并把结果集通过 ResultSetHandler进行自动映射，另外，他还处理了二级缓存的操作。从这里可以看出，我们也是可以通过插件来实现自定义的二级缓存的。
    StatementHandler是Mybatis直接和数据库执行sql脚本的对象。另外它也实现了Mybatis的一级缓存。这里，我们可以使用插件来实现对一级缓存的操作(禁用等等)。
    ParameterHandler是Mybatis实现Sql入参设置的对象。插件可以改变我们Sql的参数默认设置。
    ResultSetHandler是Mybatis把ResultSet集合映射成POJO的接口对象。我们可以定义插件对Mybatis的结果集自动映射进行修改。
    
    mybatis是通过动态代理的方式实现拦截的。

    开发：
    1）实现Interceptor接口
        三个方法：
        setProperties方法是在Mybatis进行配置插件的时候可以配置自定义相关属性，即：接口实现对象的参数配置
        plugin方法是插件用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：return Plugin.wrap(target, this);
        intercept方法就是要进行拦截的时候要执行的方法
    
    2）注解
        @Intercepts({@Signature(type = Executor.class, method = "query", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class})})
    
    3）官方示例
        @Intercepts({@Signature(type = Executor.class, method = "query", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class})})
        public class TestInterceptor implements Interceptor {
            public Object intercept(Invocation invocation) throws Throwable {
                Object target = invocation.getTarget(); //被代理对象
                Method method = invocation.getMethod(); //代理方法
                Object[] args = invocation.getArgs(); //方法参数
                // do something ...... 方法拦截前执行代码块
                Object result = invocation.proceed();
                // do something .......方法拦截后执行代码块
                return result;
            }
            public Object plugin(Object target) {
                return Plugin.wrap(target, this);
            }
        }
    https://www.jianshu.com/p/7c7b8c2c985d

Mybatis、SpringMVC线程安全？
    mybatis:
        ThreadLocal实现将获取的SqlSession与SqlSessionFactory绑定并且关联到当前线程

125.mybatis 中 #{}和 ${}的区别是什么？
   ${}是Properties文件中的变量占位符，它可以用于标签属性值和sql内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。
   #{}是sql的参数占位符，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值，比如ps.setInt(0, parameterValue)，#{item.name}的取值方式为使用反射从参数对象中获取item对象的name属性值，相当于param.getItem().getName()。
   mybatis中如果以${}形式声明为SQL传递参数，mybatis将不会进行参数预处理，会直接动态拼接SQL语句，此时就会存在被注入的风险，所以在使用mybatis作为持久框架时应尽量避免采用${}的形式进行参数传递，如果无法避免（有些SQL如like、in、order by等，程序员可能依旧会选择${}的方式传参），那就需要对传入参数自行进行转义过滤。
   jdbc提供了PreparedStatement（预处理执行语句）的方式，可以对查询参数转义。

127.RowBounds 是一次性查询全部结果吗？为什么？
    RowBounds是mybatis提供的分页类，一次性查询全部结果，然后出部分。
    用法：
        给接口增加一个RowBounds参数。
        List<Student> findStudentByRowBounds(@Param("name") String name, RowBounds rowBounds)
        
        sql映射文件，就按普通的配置，不用limit，mybatis会自动识别RowBounds，并根据传递的RowBounds参数进行分页。
        
        传参调用：List<Student> list = findStudentByRowBounds("", new RowBounds(1,1))

128.mybatis 逻辑分页和物理分页的区别是什么？
        使用RowBounds对象进行逻辑分页，它是针对ResultSet结果集执行的内存分页。
        使用pageHelper插件进行物理分页。
            @RequestMapping("/emps")  
            public String list(@RequestParam(required = false,defaultValue = "1",value = "pageNum")Integer pageNum, Map<String,Object> map){  
                //引入分页查询，使用PageHelper分页功能  
                //在查询之前传入当前页，然后多少记录  
                PageHelper.startPage(pageNum,5);  
                //startPage后紧跟的这个查询就是分页查询  
                List<Employee> emps = employeeService.getAll();  
                //使用PageInfo包装查询结果，只需要将pageInfo交给页面就可以  
                PageInfo pageInfo = new PageInfo<>(emps);  
                //pageINfo封装了分页的详细信息，也可以指定连续显示的页数  
                map.put("pageInfo",pageInfo);  
                return "list";  
            }  
129.mybatis 是否支持延迟加载？延迟加载的原理是什么？
    延迟加载：先从单表查询，需要时再从关联表去关联查询。
    原理：使用cglib创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，
          那么就会单独发送事先保存好的查询关联B对象的sql，把B查询出来，然后调用a.setB(b)。
    Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。
    在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。

130.说一下 mybatis 的一级缓存和二级缓存？
    一级缓存是SqlSession级别，二级缓存是namespace级别。
    二级缓存缺陷：
        mybatis在多表查询时，极大可能会出现脏数据。
        例如：UserMapper.xml中有大多数针对user表的操作，但是在一个XXXMapper.xml中，还有针对user单表的操作。
            这会导致user在两个命名空间下的数据不一致，如果在UserMapper.xml中做了刷新缓存的操作，
            在XXXMapper.xml中缓存仍然有效，如果有针对user的单表查询，使用缓存的结果可能会不正确。

131.mybatis 和 hibernate 的区别有哪些？
    hirbernate全自动化，不用手写sql；mybatis半自动化，sql需要手工完成。
    hirbernate提供了良好的缓存机制；mybatis本身提供的缓存机制不佳。
    hirbernate方便数据库移植；mybatis移植性不好，不同的数据库要写不同的sql。

132.mybatis 有哪些执行器（Executor）？
    三种基本的Executor执行器：SimpleExecutor、ReuseExecutor、BatchExecutor
    SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。
    ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就是用，不存在就创建，
                   用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。重复使用Statement对象。
    BatchExecutor：执行update，将所有sql都添加到批处理中（addBatch()）,等待统一执行（executeBatch()），
                   它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。
                   其底层会调用Statement的executeBatch()方法实现批量操作。
    Exexutor这些特点都严格限制在SqlSession生命周期范围内。

    Mybatis默认的Executor是SimpleExecutor。
    全局配置设置Executor：<setting name="defaultExecutorType" value="SIMPLE"/>

61，Spring+MyBatis实现读写分离简述？
    答：
    方案一：通过MyBatis配置文件创建读写分离两个DataSource，每个SqlSessionFactoryBean对象的mapperLocations属性制定两个读写数据源的配置文件。将所有读的操作配置在读文件中，所有写的操作配置在写文件中。
    方案二：通过Spring AOP在业务层实现读写分离，在DAO层调用前定义切面，利用Spring的AbstractRoutingDataSource解决多数据源的问题，实现动态选择数据源
    方案三：通过Mybatis的Plugin在业务层实现数据库读写分离，在MyBatis创建Statement对象前通过拦截器选择真正的数据源，在拦截器中根据方法名称不同（select、update、insert、delete）选择数据源。
    方案四：通过spring的AbstractRoutingDataSource和mybatis Plugin拦截器实现非常友好的读写分离，原有代码不需要任何改变。推荐第四种方案

2、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？
    答：还有很多其他的标签，<resultMap>、<parameterMap>、<sql>、<include>、<selectKey>，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中<sql>为sql片段标签，通过<include>标签引入sql片段，<selectKey>为不支持自增的主键生成策略标签。

3、最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？
    答：Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，
    就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。

    Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，
    举例：com.mybatis3.mappers.StudentDao.findStudentById，
    可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。
    在Mybatis中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MappedStatement对象。

    Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。

    Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，
    转而执行MappedStatement所代表的sql，然后将sql执行结果返回。

5、简述Mybatis的插件运行原理，以及如何编写一个插件。
    答：Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，
        Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，
        具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。
        实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。

6、Mybatis执行批量插入，能返回数据库主键列表吗？
    答：能，JDBC都能，Mybatis当然也能。

7、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？
    答：Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，
       Mybatis提供了9种动态sql标签trim|where|set|foreach|if|choose|when|otherwise|bind。
       其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。

8、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？
    答：第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。
    有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。

9、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。
    答：能，Mybatis不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把selectOne()修改为selectList()即可；多对多查询，其实就是一对多查询，只需要把selectOne()修改为selectList()即可。
    关联对象查询，有两种实现方式，一种是单独发送一个sql去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用join查询，一部分列是A对象的属性值，另外一部分列是关联对象B的属性值，好处是只发一个sql查询，就可以把主对象和其关联对象查出来。
    那么问题来了，join查询出来100条记录，如何确定主对象是5个，而不是100个？其去重复的原理是<resultMap>标签内的<id>子标签，指定了唯一确定一条记录的id列，Mybatis根据<id>列值来完成100条记录的去重复功能，<id>可以有多个，代表了联合主键的语意。
    同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。
    举例：下面join查询出来6条记录，一、二列是Teacher对象列，第三列为Student对象列，Mybatis去重复处理后，结果为1个老师6个学生，而不是6个老师6个学生。

        t_id    t_name           s_id

    |          1 | teacher      |      38 |
    |          1 | teacher      |      39 |
    |          1 | teacher      |      40 |
    |          1 | teacher      |      41 |
    |          1 | teacher      |      42 |
    |          1 | teacher      |      43 |

10、mybatis开发配置
    mybatis.xml配置文件
    dao接口文件：定义增删改查方法。
    mapper映射文件：一个映射文件对应一个dao接口，namespece为dao权限定名，sql语句对应dao接口方法，statement的Id与Mapper接口的方法名保持一致。
    dto：用于将后台的数据结构（javaBean）转换为对用户友好的表现方式的数据结构。检验注解也可以标注在dto上。
        // service中查询
        public ActionDto getById(Long id) {
            ActionDto result = new ActionDto();
            Action action = actionDao.selectById(id);
            BeanUtils.copyProperties(action, result);
            return result;
	    }
        // controller中
        /**
        * 商户新增
        */
        @RequestMapping(method = RequestMethod.POST)
        public String add(BusinessDto dto,RedirectAttributes attr) {
            if(businessService.add(dto)) {
                attr.addAttribute(PageCodeEnum.KEY, PageCodeEnum.ADD_SUCCESS);
                return "redirect:/businesses";
            } else {
                attr.addAttribute(PageCodeEnum.KEY, PageCodeEnum.ADD_FAIL);
                return "redirect:/businesses/addPage";
            }
        }
    service：dao注入到service，调用dao。


11、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？
    答：不同的Xml映射文件，如果配置了namespace，那么id可以重复；
        如果没有配置namespace，那么id不能重复；
        毕竟namespace不是必须的，只是最佳实践而已。
        原因就是namespace+id是作为Map<String, MappedStatement>的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。
        有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。


14、Mybatis中如何指定使用哪一种Executor执行器？
    答：在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。
        ...
        @Autowired  
        private SqlSessionFactory sessionFactory;  
        SqlSession session =sessionFactory.openSession(ExecutorType.BATCH,false);
         for(int i=0;i<group;i++){  
            session.update("com.com.hcd.mybatis.interfaces.CommonMapper.update", getParam());  
        }  
        session.flushStatements();  
        session.commit(); 
        ...
        private static Map<String,Object> getParam(){  
            Map param=new HashMap();  
            return param;  
        }

15、Mybatis是否可以映射Enum枚举类？
    答：Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。
       映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。
       TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，
       体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。

16、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？
    答：虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。
        原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，
        然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，
        B标签已经存在，A标签也就可以正常解析完成了。

17、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？
    答：Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。
        在Xml映射文件中，<parameterMap>标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。
        <resultMap>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。
        每一个<select>、<insert>、<update>、<delete>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>kafka<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
152.kafka 可以脱离 zookeeper 单独使用吗？为什么？

153.kafka 有几种数据保留的策略？

154.kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？

155.什么情况会导致 kafka 运行变慢？

156.使用 kafka 集群需要注意什么？

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> zookeeper >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

157.zookeeper 是什么？

158.zookeeper 都有哪些功能？

159.zookeeper 有几种部署模式？

160.zookeeper 怎么保证主从节点的状态同步？

161.集群中为什么要有主节点？

162.集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？

163.说一下 zookeeper 的通知机制？