1、JAVA中的几种基本数据类型是什么，各自占用多少字节。
    String不属于基本数据类型。
    基本数据类型：byte、short、int、long、float、double、char、boolean
    byte: 1字节
    
    short: 2字节
    char: 2字节
    
    int：4字节
    float: 4字节

    long: 8字节
    double: 8字节

    boolean：单个的boolean类型变量在编译的时候使用int类型（4字节）；
             boolean类型的数组时，在编译的时候是作为byte array来编译的，所以boolean数组里面的每一个元素占一个字节。
             
2、String类能被继承吗，为什么。
    不能，String类是被final修饰的。final修饰的类不能被继承。
    final类不能被继承。
    final方法不能被重写。
    final成员变量必须声明的时候赋值或在构造函数中赋值。
    final变量不能被再次赋值。引用的内容可以变化。
    String和Integer都是final修饰的。为了安全和效率，用的多，非常底层的一个类。
    被final修饰的函数会被直接插入到函数调用处，减少了函数调用的次数（类内部有个函数签名和函数地址的映射表）。但替换太多会导致内嵌之后的代码长度大大增加。增加了jvm解释字节码的时间。

3、String，Stringbuffer，StringBuilder的区别。
    String是不可变类，线程安全，对String进行操作时总是创建新的字符串。
    StringBuffer是可变类，线程安全。方法上都加了synchronized，而StringBuilder没有。
    StringBuilder是可变类，线程不安全。

4、ArrayList和LinkedList有什么区别。
    ArrayList：底层基于动态数组，根据下标随机访问效率高，插入元素还要移动元素效率低。
    LinkedList：底层基于双向链表，插入删除只需要移动指针效率高，查找需要遍历效率低。

5、讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。
    单类：静态变量（静态初始块） > 成员变量（非静态初始块）> 构造器
    父类子类：父类静态变量（父类静态初始块）> 子类静态变量（子类静态初始块 ）> 父类成员变量（ 父类非静态初始块） > 父类构造器 > 子类成员变量（子类非静态初始块）> 子类构造器
    静态变量和静态初始化快的初始化顺序和类中定义的顺序一致。
    成员变量和非静态初始化块初始化顺序和类中定义的顺序一致。

6、用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。
    HashMap、LinkedMap、TreeMap
    HashMap：底层数组 + 单链表（链表长度大于8时转为红黑树），每一个数组元素都是一个链表。遍历无序。
    LinkedHashMap：底层数组 + 双向链表。通过指针关联各个元素，遍历有序。
    TreeMap：底层红黑树实现，可排序。默认按照key的字典顺序来排序，也可以自定义排序规则（实现Comparator接口）

    HashMap线程不安全，多线程环境下使用ConcurrentHashmap来替换HashMap。ConcurrentHashMap将数据分为多个segment（默认16个），
    然后每次操作对一个segment加锁，每个segment都有一个自己的锁，只要多个线程访问的不是同一个segment就没有锁争用，就没有阻塞，也就是
    允许16个线程并发的更新而尽量没有锁争用。

7、JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。
    java 5之后，JDK引入了java.util.concurrent并发包，其中最常用的就是ConcurrentHashMap了，它的原理是引用了内部的Segment分段锁，
    保证在操作不同段map的时候，可以并发执行，操作同段map的时候，进行锁的竞争和等待，从而达到线程安全。
    但是java 8之后，JDK放弃了Segment，使用了synchronized。
    
    put的时候，首先通过hash找到对应链表过后，查看是否是第一个Object，如果是，直接用cas原则插入，无需加锁。
    如果不是链表第一个object，则直接用链表第一个object加synchronized锁，会一致用第一个object为锁，直到重新计算map大小。

8、有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。
    LinkedHashMap底层实现是数组+单向链表+双向链表。
    数组+单向链表就是HashMap结构，记录数据用。
    双向链表存储插入顺序用。

9、抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。
    java类不支持多继承，但是可以实现多个接口。
    接口可以继承多个接口。

12、反射的原理，反射创建类实例的三种方式是什么。
    可以在运行时判断一个对象所属的类，构造一个类的对象，判断类具有的成员变量和方法，调用1个对象的方法。
    4个关键的类：Class，Constructor，Field，Method。    
    getConstructor获得构造函数/getDeclardConstructor； 
    getField/getFields/getDeclardFields获得类所生命的所有字段；
    getMethod/getMethods/getDeclardMethod获得类声明的所有方法，正常方法是一个类创建对象，而反射是1个对象找到1个类。
    获取class对象：
        1，new student().getClass();
        2，Student.class;
        3，Class.forName("Student");
    通过Class对象获取Constructor，Field，Method。
    spring中IOC通过xml配置实例化对象，用到了反射。
    spring中的注解：首先解析所有属性，判断属性上是否存在指定注解，如果存在则根据搜索规则取得bean，然后利用反射原理注入。如果标注在字段上面，也可以通过字段的反射技术取得注解，根据搜索规则取得bean，然后利用反射技术注入。

    反射是如何实现的
        JVM实现
    如何通过反射调用对象的方法
        Class clazz = new student().getClass(); // 先获得class对象
        Method method = clazz.getMethod("test",String.class,int.class); // 再获取method对象
        Object obj1 = method.invoke(clazz.newInstance(),"xiaojun",23);  // 然后执行invoke
    如何通过反射获取和设置对象私有字段的值
        Field fields[] = obj.getClass().getDeclaredFields();getDeclaredFields()：//得到对象的所有私有属性
        for (Field field : fields) {
            field.setAccessible(true);
            field.set(obj, "ddd");//通过反射给指定字段赋值
         }
    反射机制的优缺点

13、反射中，Class.forName和ClassLoader区别 。
    ClassLoader.loadClass()也加载到JVM，但是不会执行static块，并且只有调用了new Instance方法才会调用构造函数。

14、描述动态代理的几种实现方式，分别说出相应的优缺点。
    基于JDK的实现和基于Cglib的实现
    
15、动态代理与cglib实现的区别。
    基于JDK的动态代理，需要实现一个或多个接口（InvocationHandler）；
    Cglib的方式可以代理任意一个目标类，但对final类和方法无法处理。
    JDK动态代理只代理接口，因为在调用Proxy.newProxyInstance()的时候需要传入目标类的接口类，而Cglib不做此限制。
    Cglib既可以代理接口又可以代理实现类。

    JDK动态代理机制是委托机制，动态实现接口类，在动态生成的实现类里面委托为handler去调用原始实现类。
    Cglib则使用继承机制，被代理类和代理类是继承关系。

16、基于JDK的动态代理原理？
    在java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。
    生成的代理类继承了Proxy，由于java是单继承，所以只能实现接口，通过接口实现 

16、为什么CGlib方式可以对接口实现代理。
    CGLIB底层：使用字节码处理框架ASM，来转换字节码并生成新的类。 
    CGLIB（CODE GENERLIZE LIBRARY）代理是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的所有方法，所以该类或方法不能声明称final的。
    如果目标对象没有实现接口，则默认会采用CGLIB代理； 
    如果目标对象实现了接口，可以强制使用CGLIB实现代理。

18、写出三种单例模式实现。
    简单工厂：
        一个静态方法，传入相应参数返回不同对象，也成为静态工厂。
        缺点：违反开闭原则。
    工厂方法：
        抽象工厂类、抽象产品类、具体工厂类、具体产品类。
        将具体产品的创建推迟到了具体工厂类。
        添加新产品的时候就不修改工厂类逻辑而是添加新的具体工厂类。
        缺点是：添加新产品的时候，除了要增加新产品类之外，还要具体工厂类。
                一个工厂只创建一种具体产品。
    抽象工厂：
        PC厂商是个父类，有生产鼠标，生产键盘两个接口。
        戴尔工厂继承它，工厂.生产鼠标()生产戴尔鼠标，工厂.生产键盘()则生产戴尔键盘。
        惠普工厂继承它，工厂.生产鼠标()生产惠普鼠标，工厂.生产键盘()则生产惠普键盘。
        生产产品族。

    单例模式：
        懒汉式：调用时才实例化对象。会有线程安全问题，可以双重校验锁确保线程安全。is null -> synchronized -> is null
                public static Singleton getSingleton3() { 
                    if (singleton == null) { 
                        synchronized (Singleton.class) { 
                            /** 为什么还要重新判断一下呢? 
                            * 因为同时等待锁的有可能有多个线程,当第一线程释放锁之后,后面的线程得到锁就可以进入这个方法 
                            * 这时如果不进行判断的话很有可能就会创建多个实例. 
                            */ 
                            if (singleton == null) { 
                                singleton = new Singleton(); 
                                } 
                            } 
                        } 
                        return singleton; 
                    }
                }
        恶汉式：类加载的时候实例化。利用classloader机制确保线程安全，static 属性。
    代理模式:
19、如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。

20、请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。
     	            同一个类	同一个包	不同包的子类	不同包的非子类
        private	    √	 	 	 
        default	    √	        √	 	 
        protected	√	        √	            √	 
        public	    √	        √	            √	     √
        被public修饰的类、方法、属性、可以跨类和跨包访问。
        封装、继承、多态、
21、深拷贝和浅拷贝区别。
    克隆是克隆出一个独立的对象，而不是引用。
    浅克隆无法对引用类型的属性克隆, 浅克隆的原始对象和克隆对象的引用类型成员变量将指向相同的引用内容.
    深克隆：引用类型的类也要Clonable接口，并重写clone()，然后在对引用类型属性也调用clone()方法。user.mark = (Mark) this.mark.clone();
        @Override
        protected Object clone() throws CloneNotSupportedException {
            User user = (User) super.clone();
            user.mark = (Mark) this.mark.clone();
            return user;
        }
    克隆的对象可能包含一些已经修改过的属性，而new1个对象属性都还是初始化时候的值，被复制克隆的类要实现Clonable接口，覆盖clone()方法，
    访问修饰符为public，方法中调用super.clone()得到所需要的复制方法，类中的属性类也需要实现Clonable接口，
    覆写clone()方法，并在super中也调用子属性类的clone()复制，才可以实现深拷贝。
    
    或者写到流中序列化的方式来实现，不必考虑引用类型中还包含引用类型，直接用序列化来实现对象的深复制拷贝，即将对象写到流，再从流中读出来，需要实现seriazation接口。

25、什么是类加载？
    负责读取java字节代码，并转换成java.lang.Class类的一个实例。通过此实例的 newInstance()方法就可以创建出该类的一个对象。
    基本上所有的类加载器都是 java.lang.ClassLoader类的一个实例。

26、java.lang.Class类
    java.lang.Class类，它的对象用来描述一个运行状态的类或接口。一个xxx.java文件编译后生成一个xxx.class文件，一个xxx.class文件被JVM加载后生成该类对应的Class对象，该对象包含了该类的所有信息，
    比如：类中有字段、构造器、方法等信息。一个类有一个对应的Class对象，元素类型相同且长度相同的数组共享一个Class对象，java基本类型包括void都有各自的Class对象。

27、什么是类加载器？
    jdk提供了三种类加载器：
        Bootstrp Classloader(启动类加载器): c++编写，在jvm启动后初始化，主要负责%JAVA_HOME%/jre/lib，%JAVA_HOME%/jre/classes，-Xbootclasspath参数执行的路径中的类。
        ExtClassLoader(拓展类加载器，java 9改为Platform Loader): Bootstrp loader加载ExtClassLoader，并且将ExtClassLoader的父加载器设置为Bootstrp loader。
                        ExtClassLoader是java编写（sun.misc.Launcher$ExtClassLoader）
                        加载%JAVA_HOME%/jre/lib/ext路径下以及 java.ext.dirs系统变量指定的路径中类库。
        AppClassLoader(应用程序类加载器): 加载完ExtClassLoader后，就会加载AppClassLoader，并且将AppClassLoader的父加载器指定为ExtClassLoader。
                        java编写。实现类是sun.misc.Launcher$AppClassLoader.
                        ClassLoader中有个getSystemClassLoader方法，此方法返回的正是AppclassLoader。
                        AppClassLoader主要负责加载classpath所指定的位置的类或者jar文档，是java默认的类加载器。
    自定义类加载器
        通过继承ClassLoader类实现，主要重写findClass方法。
    类全名和类加载器一致的类才是相同的类，被不同的类加载器加载之后得到的类也是不同的。

28、JDK目录
    /bin: jdk的各种工具命令。javac、java、jconsole等。
    /db
    /include：支持本地方法的C头文件。
    /jre
        /lib:
        /classes
    /lib

29、双亲委派是什么？
    子加载器接收到了类加载请求，但子加载器首先不会去尝试加载类而是委托给父加载器去加载。父加载器重复这一操作，直到顶层加载器，父加载器无法加载会交给子加载器。

30、为什么要双亲委派？
    1) 可以避免重复加载，当父加载器已经加载了该类的时候，子加载器就没必要再加载一次。
    2) 为了安全，java核心的类不会被随意替换，假设通过网络传递一个名为java.lang.String的类，通过双亲委派传递到启动类加载器，启动类发现已经加载过就不会重复加载，而直接返回已加载过String.class。

31、可以不可以自己写个String类
    不可以，自定义的String类不能替换掉JDK本身的String类。
    就算自己写一个classLoader加载器类来加载自己写的java.lang.String类，但是不会加载成功，因为java.*开头的类，jvm的实现中保证了必须由启动类加载器来加载。

32、为什么要破坏双亲委派？
    某些情况下父加载器需要委托子加载器去加载class文件。受到加载范围的限制，父加载器无法加载到需要的文件。
    以Driver接口为例，由于Driver接口定义在jdk中，而其实现由各个数据库的服务商来提供，比如mysql就写了MySQL Connector，DriverManager（jdk提供）要加载各个实现了Driver接口的实现类，
    然后进行管理，但是DriverManager由启动类加载器加载，只能加载JAVA_HOME的lib文件，这个时候父加载器只能委托子加载器来加载Driver实现。这就破坏了双亲委派。

33、如何破坏双亲委派？
    1、双亲委派模型出现之前，即JDK 1.2发布之前。
    2、JDBC中Driver类需要动态去加载不同数据库类型的Driver类，用户的Driver类不能由启动类加载器去加载，应该由应用程序加载类去进行类加载。
      引入了线程上下文类加载器，可以把原本需要由启动类加载器进行加载的类由应用程序类加载器进行加载。
      获取系统类加载器：Thread.currentThread().getContextClassLoader()

34、Thread.getContextClassLoader和ClassLoader.getClassLoader的区别
    getClassLoader()返回该类的类加载器，如果是bootstrp加载器加载的类返回Null。
    getContextClassLoader()返回线程上下文加载器（TCCL）。线程创建者在创建线程之后会用对应的setContextClassLoader()方法将合适的类加载器设置到线程中。
    如果不设置默认是系统类加载器就是AppClassLoader。
    有些框架为了做类的隔离会通过不同的ClassLoader来做类的隔离，假设框架提供了一个可拓展的服务接口，这个接口的类加载器是AppClassLoader，但是这个接口的实现
    则交给使用者来拓展，那么实现类很有可能被自定义的ClassLoader加载导致AppClassLoader无法找到实现类。如果在框架的层面希望能够获取到接口实现类就需要将实现类
    用getContextClassLoader获得的ClassLoader来加载。

9、修改类加载策略要复写哪个方法？
    loadClass()：先查看Class是否已经加载，如果没有，则递归到父加载器，如果父加载器还没找到，则调用findClass()
    findClass()：根据名称或位置加载.class字节码，然后使用desineClass
    defineClass()：将字节码转换为Class实例。

10、知道模块化吗？

11、知道Java9的模块化技术吗？

12、jigsaw，jboss modules和osgi的区别？

13、ClassNotFoundException和NoClassDefFoundErr区别？
    ClassNotFoundException：是一个异常，Class.forName、 ClassLoader.loadClass、 ClassLoader.findSystemClass在动态加载类到内存中的时候可能会抛出这个异常。
                            在类路径中找不到类。
    NoClassDefFoundErr：要查找的类在编译的时候是存在的，运行的时候却找不到了。
    加载时从外存储器找不到需要的class就出现ClassNotFoundException 
    连接时从内存找不到需要的class就出现NoClassDefFoundError

14、包冲突、类冲突、模块化
    包冲突：
        A->B->C->D_1
        E->F->D_2
        依赖不同的版本D，但maven只会加载一个D。
        maven加载jar的时候，按最短路径、最先声明优先。
        移除冲突包：
            1）可使用Maven Helper插件中的Dependency Analyzer分析冲突的jar包，然后移除。
            2）使用<exclusions>标签排除冲突的jar包，maven helper等同于该方法。
        分析包冲突：
            mvn dependency:tree

15、SPI
    SPI（Service Provider Interface）是JDK内置的一种提供服务发现的机制。
    java中子类获取父类或接口信息非常方便，但是根据一个接口获取该接口的所有实现类却并不那么容易。
    一个方法是可以扫描classpath下所有的class与jar包中的class，接着用ClassLoader加载进来，再判断是否是给定接口的子类。但是代价太大。
    java推出了ServiceLoader类来提供服务发现机制，动态的为某个接口寻找服务实现，当服务的提供者提供了服务接口的一种实现之后，必须根据SPI约定在META-INF/services/目录
    创建一个以服务接口命名的文件，该文件里写的就是实现该服务接口的具体实现类。当程序调用ServiceLoader的load方法的时候，ServiceLoader能够通过约定的目录找到指定的文件，
    并装载实例化，完成服务的发现。
    public class SPITest {
        public static void main(String[] args) {
            ServiceLoader<Animal> load = ServiceLoader.load(Animal.class);
            Iterator<Animal> iterator = load.iterator();
            while(iterator.hasNext()){
                Animal animal = iterator.next();
                animal.eat();
            }
        }
    }   
    ServiceLoader首先找到接口文件，然后解析出文件中的所有服务实现类并加载实例化。
    JDBC使用了SPI机制，让所有的任务都交给不同的数据库厂商各自去完成，无论是实现Driver接口，还是SPI要求的接口文件，都做到了让用户不需要关心一点细节。
    
26、说一说你对java.lang.Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。
    为什么需要hashCode?
    1、在map等集合中，通过hashCode可以很快的找到元素的位置
    2、比较两个对象是否相等时，先通过hashCode比较，这样速度比较快，如果不相等直接返回false

    为什么要重载equal方法？
    Object对象默认比较的是两个对象的内存地址是否一样，正常大家应该比较的是对象里面的值是否一样。

    为什么重载hashCode方法？
    如果我们只重写equals，而不重写hashCode方法，就会出现两个对象一样，但是hashCode不相等情况，在map等集合中应用时，就会出现问题，因为hashCode不一样，两个一样的对象会放到集合中。

27、向上转型、向下转型
    向上转型：B extends A;  A a = new B()就是向上转型，即父类的引用指向子类的对象。此时a不能调用子类自己新建的方法和变量，但是如果子类重写了父类的方法，则会调用子类的方法。
    向下转型：B extends A;  A a = new B(); B b = (B)a;就是向下转型。向下转型后b对象又可以调用子类自己的方法了。
    不安全的向下转型：
        A a = new A(); 
        B b = (B)a;
        a是父类对象，子类的实例b肯定不能指向父类a。
    向下转型存在风险，所以最好先用if(a instanceof B)判断一下。
    instanceof ：
        在运行时指出对象是否是特定类的一个实例。object instanceof class
        在编译状态中，class可以是object对象的父类，自身类，子类。在这三种情况下Java编译时不会报错。
        在运行转态中，class可以是object对象的父类，自身类，不能是子类。在前两种情况下result的结果为true，最后一种为false。但是class为子类时编译不会报错。运行结果为false。
28、泛型
    在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。
        早期Java是使用Object来代表任意类型的，但是向下转型有强转的问题。

    什么是泛型，如何使用（使用在哪些地方）？Java中的泛型是如何工作的？

    什么是泛型通配符？ 在什么情况下使用？

29、如何获取泛型对应的实际类型？
    通过反射，先拿到参数，然后取参数类型
30、泛型是如何实现的？ List、List<T>、List<?>、List<Object> 的区别？
        编译的时候擦除了。
        List: 接受任何类型。
            ArrayList arrayList = new ArrayList();
            arrayList.add(123);
            arrayList.add("sss");
        List<T>：
        List<?>：是一个泛型，在没有赋值前，表示可以接受任何类型的集合赋值，但赋值之后不能往里面随便添加元素
        List<Object>

31、Java中的HashSet内部是如何工作的。
    无序集合。
    HashSet是基于HashMap实现的，底层采用HashMap来保存元素。
    将相应的内容存储在一个hashmap的key中，然后再去读取。
    为了保证hashset的唯一性，hashmap里的value保存同一个对象：
    private static final Object PRESENT = new Object();

    HashSet按Hash算法来存储集合中的元素，因此具有很好的存取和查找性能。

32、TreeSet的原理？
    有序集合。
    基于TreeMap实现的。
    支持两种排序方式：自然排序或者创建TreeSet时提供的Comparator进行排序。

32、HashMap,HashSet的区别？

32、什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。
    https://www.cnblogs.com/kubixuesheng/p/10350523.html
    为了网络传输或本地保存，可直接反序列化还原对象。
    
    序列化和反序列化即对象和字节序列间的转化，进程间传送文本图片音频等以二进制传送。
    JDK中ObjectOuputStream和ObjectInputStream为输出输入流，只有实现SeriaLizable/Externalizable接口的类才能被序列化。
    1、序列化一个对象首先要创造某些OutputStream对象(如FileOutputStream、ByteArrayOutputStream等)，然后将其封装在一个ObjectOutputStream对象中，在调用writeObject()方法即可序列化一个对象
    2、String类型的对象、枚举类型的对象、数组对象，都是默认可以被序列化的。
    3、如果仅仅让某个类实现Serializable接口，而没有其它任何处理的话，则就是使用默认序列化机制。
        使用默认机制在序列化对象时，不仅会序列化当前对象，还会对该对象引用的其它对象也进行序列化，同样地，这些其它对象引用的另外对象也将被序列化，以此类推。
        所以，如果一个对象包含的成员变量是容器类对象，而这些容器所含有的元素也是容器类对象，那么这个序列化的过程就会较复杂，开销也较大。
    4、当类的某个字段被 transient 修饰，默认序列化机制就会忽略该字段。
    5、如果一个类想被序列化，需要实现 Serializable 接口进行自动序列化，或者实现 Externalizable 接口进行手动序列化，否则强行序列化该类的对象，就会抛出 NotSerializableException 异常，这是因为，在序列化操作过程中会对类型进行检查，要求被序列化的类必须属于 Enum、Array 和 Serializable 类型其中的任何一种（Externalizable也继承了Serializable）。
    6、序列化并不保存静态变量，要想将父类对象也序列化，就需要让父类也实现Serializable接口。如果一个类的字段有引用对象，那么该引用类型也要实现Serializable接口。
    7、如果父类没有实现Serializable接口，但其子类实现了此接口，那么这个子类是可以序列化的，但是在反序列化的过程中会调用父类的无参构造函数，所以在其直接父类（注意是直接父类）中必须有一个无参的构造函数。
    
    反序列化的过程需要创造InputStream对象(如FileInputstream、ByteArrayInputStream等)，然后将其封装在ObjectInputStream中，在调用readObject()即可
    注意对象的序列化是基于字节的，不能使用基于字符的流。

33、java7、java8的新特性。
    java 7 :
        在switch中使用字符串；自动关闭资源（必须实现AutoCloseable接口）。
    java8 引入了语言特性lambda表达式；Optional 类；Stream API。
        lambda: 三部分（参数、箭头、方法体可以返回值也可以不返回任何东西）
            1. (params) -> expression
            2. (params) -> statement
            3. (params) -> { statements }
            ()->10; // 直接返回10
            (int x, int y) -> x+y; // 接受两个int类型的参数，并返回这两个参数相加的和
            (x, y) -> x + y; //接受两个参数，该参数的类型由JVM根据上下文推断出来，并返回两个参数的和
            (String name) -> System.out.println(name); //
            name -> System.out.println(name); //
            (String name, String sex) -> {System.out.println(name); System.out.println(sex); }
            x -> 2*x; 
        Stream：流Stream。可以和lambda结合。
            生成流：
                串行流：stream()
                并行流：parallelStream()
            获取经字符串的数量：
                List<String> strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl");
                // 获取空字符串的数量
                int count = strings.parallelStream().filter(string -> string.isEmpty()).count();
        Optional类：
            Optional类主要解决的问题是臭名昭著的空指针异常。链式调用的时候可能会有某个环节出现空指针。
            String isocode = user.getAddress().getCountry().getIsocode().toUpperCase();
    
    java9 引入了module。

    java10 可以用var声明局部变量。

36、session和cookie的区别和联系，session的生命周期，多个服务部署时session管理。
    1）spring boot设置session超时：server.servlet.session.timeout=3660s
    2）web.xml文件中设置超时：
        ```
        <session-config>
            <session-timeout>20</session-timeout>
        </session-config>
        ```
    3）Spring Session支持的仓库有Redis、MongoDB、JDBC
        ```
        依赖：
        <dependency>
            <groupId>org.springframework.session</groupId>
            <artifactId>spring-session-data-redis</artifactId>
        </dependency>
        <dependency>
            <groupId>redis.clients</groupId>
            <artifactId>jedis</artifactId>
            <version>2.9.0</version>
        </dependency>
        
        注解：
        @Configuration
        // 设置session的失效时间
        @EnableRedisHttpSession(maxInactiveIntervalInSeconds = 120) 
        public class RedisHttpSessionConfiguration {
        }
        ```
        ```
        设置session
        @RequestMapping("/")
        public String Index(@RequestParam("name") String name, HttpServletRequest request, HttpSession session){

            Cookie[] cookies = request.getCookies();
            if (cookies != null && cookies.length > 0) {
                for (Cookie cookie : cookies) {
                    if (cookie.getName().contains("JSESSION")) {
                        System.out.println(cookie.getName() + "=" + cookie.getValue());
                    }
                }
            }
            Object value = session.getAttribute("username");
            if (value == null) {
                System.out.println("用户不存在");
                session.setAttribute("username", "{username: '" + name+ "', age: 28}");
            } else {
                System.out.println("用户存在");
            }

            return "username=" + value;
        }
        ```
37、Java中的队列都有哪些，有什么区别。
    1）不阻塞队列：
        PriorityQueue：类实质上维护了一个有序列表。加入到 Queue 中的元素根据它们的天然排序（通过其 java.util.Comparable 实现）或者根据传递给构造函数的 java.util.Comparator 实现来定位。
        ConcurrentLinkedQueue：
    2）实现了阻塞接口：
        * ArrayBlockingQueue ：一个由数组支持的有界队列。
        * LinkedBlockingQueue ：一个由链接节点支持的可选有界队列。
        * PriorityBlockingQueue ：一个由优先级堆支持的无界优先级队列。
        * DelayQueue ：一个由优先级堆支持的、基于时间的调度队列。
        * SynchronousQueue ：一个利用 BlockingQueue 接口的简单聚集（rendezvous）机制。

39、HashMap的源码，实现原理，底层结构。
    HashMap底层有数组加链表组成，链表长度大于8时转为红黑树。
    底层是数组，数组的每一项又是一个链表。
    put操作：
        1）对key的hashcode()做hash，然后计算index。
        2）如果没有碰撞就放到bukcet里。
        3）如果碰撞了，以链表的形式存在bockets后。
        4）(e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))
    get操作：
        1）bucket（桶/数组元素和下面的链表）里的第一个节点，直接命中；
        2）如果有冲突，则通过key.equals(k)去查找对应的entry。
    https://www.jianshu.com/p/316284bf1217

42、了解LinkedHashMap的应用吗

43、cloneable接口实现原理？
    Cloneable接口没有任何方法。
    实现Cloneable接口表示该类可以被克隆。
    表示接口支持克隆。
    clone()是被本地方法实现。

44、Java NIO使用
    https://www.zhihu.com/question/342093305/answer/801167091
45、hashtable和hashmap的区别及实现原理，hashmap会问到数组索引，hash碰撞怎么解决

50、TreeMap的实现原理
    红黑树

52、什么是 对象/关系 映射集成模块
    ORM
    对象和数据库的映射，可以不必关心数据库怎么存储，操作数据库像操作对象一样。

55、fail-fast 与 fail-safe 机制有什么区别
    fail-fast（快速失败）：
        在用迭代器迭代一个集合时，如果遍历过程中对集合内容做了修改，则会抛出异常。
        对集合做了修改则会改变modCount变量，使用hashNext/next()遍历下一个元素之前，都会检测modCount变量是否改变。
        如果集合发生变化时修改modCount值刚好又设置了expectedmodCount值，则异常不会抛出。
        场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改。
    fail-safe（安全失败）：
        遍历集合的时候，先复制原有集合内容，在拷贝的集合上遍历。
        场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用。

58、IO 和 NIO的区别，NIO优点

60、一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制
    可以包含多个类，但是只允许一个有public类，并且类名必须和文件名一致。
    如果一个文件有多个public类，程序就不知道从哪里进入。

66、static关键字有哪些用法
    方便在没有创建对象的情况下来进行调用（方法、变量）。
    在static方法内部不能调用非静态方法，反过来可以。
    可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。

69、this、super什么时候使用
    this相当于对象自身。
    super：
        可以理解为父类对象。
        super.xxx引用父类属性。
        super.xxx()调用父类方法或构造函数。

70、public static void 写成 static public void会怎样
    效果一样。
    习惯上是[访问限定符] [static] [final] [类型名]
    说明一下public static void main(String args[])这段声明里每个关键字的作用
    args获取命令行传参：java test a b c

71、sizeof 是Java 的关键字吗

73、switch
    switch 语句中的变量类型可以是： byte、short、int 或者 char。
    从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。

75、操作符
    3*0.1 == 0.3 将会返回什么？true 还是 false？ 
        false, 浮点数不能精确表示。
        使用BigDecimal。BigDecimal的解决方案就是，不使用二进制，而是使用十进制（BigInteger）+小数点位置(scale)来表示小数。

    float f=3.4; 是否正确？
        在java里面，没小数点的默认是int,有小数点的默认是 double; 
        编译器可以自动向上转型，如int 转成 long 系统自动转换没有问题，因为后者精度更高 
        double 转成 float 就不能自动做了，所以后面的加上个 f;

    short s1 = 1; s1 = s1 + 1;有什么错?
        低类型和高类型运算时必须转换成高类型，s1转换为int然后+1，此时由值为int型，再复制给左侧的short，精度丢失。
    
    short s2 = 1; s2 += 1;
        正确。编译器做了处理。

76、基本类型
    int 和 Integer 哪个会占用更多的内存？ 
        Integer是个对象，不仅保存数值，还会在堆中保存对象引用。
    parseInt()函数在什么时候使用到
        int x =Integer.parseInt("9");
        double c = Double.parseDouble("5");
        int b = Integer.parseInt("444",16);
    float和double的默认值是多少
       0.0 
    如何去小数四舍五入保留小数点后两位
        // 直接截掉
        double d = 114.145;
        double d = 114.145;
        DecimalFormat df = new DecimalFormat("#.00");
        String str = df.format(d);
        
        // 保留后两位，四舍五入
        String.format("%.2f", d);

    char 型变量中能不能存贮一个中文汉字，为什么
        char占两字节，Unicode编码使用两个字节。

77、类型转换
    怎样将 bytes 转换为 long 类型
    怎么将 byte 转换为 String
    如何将数值型字符转换为数字
    我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象
    能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗
    类型向下转换是什么

78、数组
    如何权衡是使用无序的数组还是有序的数组
    怎么判断数组是 null 还是为空
    怎么打印数组？ 怎样打印数组中的重复元素
    Array 和 ArrayList有什么区别？什么时候应该使用Array而不是ArrayList
    数组和链表数据结构描述，各自的时间复杂度
    数组有没有length()这个方法? String有没有length()这个方法

80、ByteBuffer 与 StringBuffer有什么区别
    1）String 转换 ByteBuffer：
        private ByteBuffer convertStringToByte(String content) throws UnsupportedEncodingException {
            return ByteBuffer.wrap(content.getBytes("utf-8"));
        }
        
    2）ByteBuffer 转换 String：
        public String decode(ByteBuffer bb) {  
            Charset charset = Charset.forName("utf-8");
            return charset.decode(bb).toString();   
        } 
    4）byte[] 转 ByteBuffer
        ByteBuffer buffer = ByteBuffer.wrap(Bytes[]);
81、HashMap
    HashMap的工作原理是什么
    内部的数据结构是什么
    HashMap 的 table的容量如何确定？loadFactor 是什么？ 该容量如何变化？这种变化会带来什么问题？
    HashMap 实现的数据结构是什么？如何实现
    HashMap 和 HashTable、ConcurrentHashMap 的区别
    HashMap的遍历方式及效率
    HashMap、LinkedMap、TreeMap的区别
    如何决定选用HashMap还是TreeMap
    如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办
    HashMap 是线程安全的吗？并发下使用的 Map 是什么，它们内部原理分别是什么，比如存储方式、 hashcode、扩容、 默认容量等
82、
    HashSet
    HashSet和TreeSet有什么区别
    HashSet 内部是如何工作的
    WeakHashMap 是怎么工作的？

82、Set
    Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢？是用 == 还是 equals()？ 它们有何区别?
    TreeMap：TreeMap 是采用什么树实现的？TreeMap、HashMap、LindedHashMap的区别。TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？
    TreeSet：一个已经构建好的 TreeSet，怎么完成倒排序。
    EnumSet 是什么

83、Hash算法
    Hashcode 的作用
    简述一致性 Hash 算法
    有没有可能 两个不相等的对象有相同的 hashcode？当两个对象 hashcode 相同怎么办？如何获取值对象
    为什么在重写 equals 方法的时候需要重写 hashCode 方法？equals与 hashCode 的异同点在哪里
    a.hashCode() 有什么用？与 a.equals(b) 有什么关系
    hashCode() 和 equals() 方法的重要性体现在什么地方
    Object：Object有哪些公用方法？Object类hashcode,equals 设计原则？ sun为什么这么设计？Object类的概述
    如何在父类中为子类自动完成所有的 hashcode 和 equals 实现？这么做有何优劣。
    可以在 hashcode() 中使用随机数字吗？

84、LinkedHashMap
    LinkedHashMap 和 PriorityQueue 的区别是什么

85、List
    List, Set, Map三个接口，存取元素时各有什么特点
    List, Set, Map 是否继承自 Collection 接口
    遍历一个 List 有哪些不同的方式
    LinkedList
    LinkedList 是单向链表还是双向链表
    LinkedList 与 ArrayList 有什么区别
    描述下 Java 中集合（Collections），接口（Interfaces），实现（Implementations）的概念。LinkedList 与 ArrayList 的区别是什么？
    插入数据时，ArrayList, LinkedList, Vector谁速度较快？
    ArrayList
    ArrayList 和 HashMap 的默认大小是多数
    ArrayList 和 LinkedList 的区别，什么时候用 ArrayList？
    ArrayList 和 Set 的区别？
    ArrayList, LinkedList, Vector的区别
    ArrayList是如何实现的，ArrayList 和 LinkedList 的区别
    ArrayList如何实现扩容
    Array 和 ArrayList 有何区别？什么时候更适合用Array
    说出ArraList,Vector, LinkedList的存储性能和特性

86、Map
    Map, Set, List, Queue, Stack
    Map 接口提供了哪些不同的集合视图
    为什么 Map 接口不继承 Collection 接口

87、Collections
    介绍Java中的Collection FrameWork。集合类框架的基本接口有哪些
    Collections类是什么？Collection 和 Collections的区别？Collection、Map的实现
    集合类框架的最佳实践有哪些
    为什么 Collection 不从 Cloneable 和 Serializable 接口继承
    说出几点 Java 中使用 Collections 的最佳实践？
    Collections 中 遗留类 (HashTable、Vector) 和 现有类的区别

88、什么是 B+树，B-树，列出实际的使用场景。

89、接口
    Comparator 与 Comparable 接口是干什么的？列出它们的区别

90、对象
    拷贝(clone)
    如何实现对象克隆
    深拷贝和浅拷贝区别
    深拷贝和浅拷贝如何实现激活机制
    写clone()方法时，通常都有一行代码，是什么

    比较
    在比较对象时，”==” 运算符和 equals 运算有何区别
    如果要重写一个对象的equals方法，还要考虑什么
    两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对

    构造器
    构造器链是什么
    创建对象时构造器的调用顺序

    不可变对象
    什么是不可变象（immutable object）
    为什么 Java 中的 String 是不可变的（Immutable）
    如何构建不可变的类结构？关键点在哪里
    能创建一个包含可变对象的不可变对象吗
    如何对一组对象进行排序

91、方法
    构造器（constructor）是否可被重写（override）
    方法可以同时即是 static 又是 synchronized 的吗
    abstract 的 method是否可同时是 static，是否可同时是 native，是否可同时是synchronized
    Java支持哪种参数传递类型
    一个对象被当作参数传递到一个方法，是值传递还是引用传递
    当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递
    我们能否重载main()方法
    如果main方法被声明为private会怎样

92、异常
    基本概念
    Error 和 Exception有什么区别
    UnsupportedOperationException是什么
    NullPointerException 和 ArrayIndexOutOfBoundException 之间有什么相同之处
    什么是受检查的异常，什么是运行时异常
    运行时异常与一般异常有何异同
    简述一个你最常见到的runtime exception(运行时异常)

    finally
    finally关键词在异常处理中如何使用
    如果执行finally代码块之前方法返回了结果，或者JVM退出了，finally块中的代码还会执行吗
    try里有return，finally还执行么？那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后
    在什么情况下，finally语句不会执行
    throw 和 throws 有什么区别？
    OOM你遇到过哪些情况？你是怎么搞定的？
    SOF你遇到过哪些情况？
    既然我们可以用RuntimeException来处理错误，那么你认为为什么Java中还存在检查型异常
    当自己创建异常类的时候应该注意什么
    导致空指针异常的原因
    异常处理 handle or declare 原则应该如何理解
    怎么利用 JUnit 来测试一个方法的异常
    catch块里别不写代码有什么问题
    你曾经自定义实现过异常吗？怎么写的
    什么是 异常链
    在try块中可以抛出异常吗

93、JDBC
    通过 JDBC 连接数据库有哪几种方式
    阐述 JDBC 操作数据库的基本步骤
    JDBC 中如何进行事务处理
    什么是 JdbcTemplate
    什么是 DAO 模块
    使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能
    列出 5 个应该遵循的 JDBC 最佳实践
    java调用jdbc连接数据库的具体步骤
    preStatement和Statement的区别

94、IO
    File
    File类型中定义了什么方法来创建一级目录
    File类型中定义了什么方法来判断一个文件是否存在

95、流
    为了提高读写性能，可以采用什么流
    Java中有几种类型的流
    JDK 为每种类型的流提供了一些抽象类以供继承，分别是哪些类
    对文本文件操作用什么I/O流
    对各种基本数据类型和String类型的读写，采用什么流
    能指定字符编码的 I/O 流类型是什么
    1.java IO了解吗？
    2.InputStream 和reader流的区别
    3.给一个JDK编码的，以UTF-8编码输出的方法


97、Socket
    socket 选项 TCP NO DELAY 是指什么
    Socket 工作在 TCP/IP 协议栈是哪一层
    TCP、UDP 区别及 Java 实现方式

98、说几点 IO 的最佳实践
    直接缓冲区与非直接缓冲器有什么区别？
    怎么读写 ByteBuffer？ByteBuffer 中的字节序是什么
    当用System.in.read(buffer)从键盘输入一行n个字符后，存储在缓冲区buffer中的字节数是多少
    如何使用扫描器类（Scanner Class）令牌化

99、面向对象编程（OOP）
    解释下多态性（polymorphism），封装性（encapsulation），内聚（cohesion）以及耦合（coupling）
    多态的实现原理
    封装、继承和多态是什么
    对象封装的原则是什么?

100、类
    获得一个类的类对象有哪些方式
    重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？
    说出几条 Java 中方法重载的最佳实践
    抽象类
    抽象类和接口的区别
    抽象类中是否可以有静态的main方法
    抽象类是否可实现(implements)接口
    抽象类是否可继承具体类(concrete class)
    匿名类（Anonymous Inner Class）
    匿名内部类是否可以继承其它类？是否可以实现接口

101、内部类
    内部类分为几种
    内部类可以引用它的包含类（外部类）的成员吗
    请说一下 Java 中为什么要引入内部类？还有匿名内部类
    继承
    继承（Inheritance）与聚合（Aggregation）的区别在哪里
    继承和组合之间有什么不同
    为什么类只能单继承，接口可以多继承
    存在两个类，B 继承 A，C 继承 B，能将 B 转换为 C 么？如 C = (C) B
    如果类 a 继承类 b，实现接口c，而类 b 和接口 c 中定义了同名变量，请问会出现什么问题

102、接口
    接口是什么
    接口是否可继承接口
    为什么要使用接口而不是直接使用具体类？接口有什么优点

104、工具类
    日历
    Calendar Class的用途
    如何在Java中获取日历类的实例
    解释一些日历类中的重要方法
    GregorianCalendar 类是什么
    SimpleTimeZone 类是什么
    Locale类是什么
    如何格式化日期对象
    如何添加小时(hour)到一个日期对象(Date Objects)
    如何将字符串 YYYYMMDD 转换为日期
    Math
    Math.round()什么作用？Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？

105、XML
    XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？DOM 和 SAX 解析器有什么不同？
    Java解析XML的方式
    用 jdom 解析 xml 文件时如何解决中文问题？如何解析
    你在项目中用到了 XML 技术的哪些方面？如何实现

106、动态代理
    描述动态代理的几种实现方式，分别说出相应的优缺点

107、设计模式
    什么是设计模式（Design Patterns）？你用过哪种设计模式？用在什么场合
    你知道哪些商业级设计模式？
    哪些设计模式可以增加系统的可扩展性
    单例模式
    除了单例模式，你在生产环境中还用过什么设计模式？
    写 Singleton 单例模式
    单例模式的双检锁是什么
    如何创建线程安全的 Singleton
    什么是类的单例模式
    写出三种单例模式实现
        调用时候
    适配器模式
    适配器模式是什么？什么时候使用
    适配器模式和代理模式之前有什么不同
    适配器模式和装饰器模式有什么区别
    什么时候使用享元模式
    什么时候使用组合模式
    什么时候使用访问者模式
    什么是模板方法模式
    请给出1个符合开闭原则的设计模式的例子

108、面向对象的特点
109、java继承有哪几种？顶级类是什么？
112、修改equals的时候为何要修改hashcode()
    equals不同，hashcode不必相同，因为不同的对象应该具有不同的散列值。
    equals相同，hashcode必须相同。
    如果不这样做到话，就会违反Object.hashCode的通用约定，从而导致该类无法与所有基于散列值(hash)的集合类结合在一起正常运作，这样的集合类包括hashMap、HashSet和Hashtable。
    Object中的hashcode是JVM根据某种策略生成的。
113、如果让你设计一个类作为hashMap的key，你会注意什么 （就是设计hashcode时候会注意什么）
115、hashmap
    1 刚才讲到了hashMap,那你就讲一下hashMap的具体实现。
    2 你会如何做的线程安全的hashMap
    3 了解过jdk1.8吗？ 对于hashMap底层进行修改过。（链改成了红黑树）
    4 那么当数量达到多少时候，会改成红黑树？
    5 底层中扩容的方法叫什么？
    往一个hashMap中添加一个元素的具体步骤
116、写单例模式， 需要lazy loading的
    我写了2个，其中一个双重判断，然后面试问我：
    2 很多人在写双重判断的时候会加入双重上锁，为什么呢？
    回答后面试官又问我
    3 知道jdk 1.5之后添加的一种实现单例模式的讨巧方法吗？
    4 enum 如何实现单例模式？
118、设计一个Hash Table
     你这个HASHTABLE会扩容吗？ 假设这个时候已经使用了1G内存，只剩下一点点内存，你如何扩容
119、大数据解决问题：
    给你大量 id->ip, ip属于一个国家，请你设计大数据解决方法，统计出 对应国家数大于3的Iid

220、Java中的switch语句的参数？python中有无switch语句？

222、大数据排序？和取最大前N条？
223、Java中类加载的过程?类加载器？
224、动态加载类的框架了解哪些？
225、动态代理一般有哪几种实现方式？动态代理的应用场景有哪些？
226、如何实现不可变的类？
228、HashMap、HashTable、ConcurrentHashMap的区别？
229、CAS是一种什么样的同步机制？

230、NIO的原理，包括哪几个组件？

231、简单介绍一下java的反射机制？反射在哪些地方有应用场景？
232、java中的引用有几种?
    Java中的threadlocal是怎么用的? threadlocal中的内部实现是怎么样的? 哪种引用?
    java中的"final"关键字在多线程的语义中，有什么含义
    说说nio的架构，为什么变快了，说说select和buffer都是怎么用的？
    在操作系统中的实现原理? 如果都是cpu轮训话，会不会对cpu影响太大?
    ArrayList的实现原理，如何测试ArrayList动态分配内存中带来的内存、cpu变化
    ArrayList是不是线程安全的? 怎么实现线程安全的?
    volatile的作用，如果volatile修饰的对象经过了大量的写，会出现什么问题？
    String的+和StringBuilder有什么区别? 放在循环中有什么问题？
    日志打印的过程中，使用String的+操作和使用占位符输出，对性能上有什么区别
    SimpleDateFormat如果是一个全局变量的话，有什么问题？
    HashMap的操作中，直接使用keySet()遍历有什么问题？
233、ArrayList和LinkedList区别？
234、HashMap内部数据结构？
235、ConcurrentHashMap分段锁？
236、jdk1.8中，对hashMap和concurrentHashMap做了哪些优化
237、如何解决hash冲突的，以及如果冲突了，怎么在hash表中找到目标值
238、1、private修饰的方法可以通过反射访问，那么private的意义是什么
2、Java类初始化顺序
3、对方法区和永久区的理解以及它们之间的关系
4、一个java文件有3个类，编译后有几个class文件
5、局部变量使用前需要显式地赋值，否则编译通过不了，为什么这么设计
6、ReadWriteLock读写之间互斥吗
7、Semaphore拿到执行权的线程之间是否互斥
8、写一个你认为最好的单例模式
9、B树和B+树是解决什么样的问题的，怎样演化过来，之间区别
10、写一个生产者消费者模式
11、写一个死锁
12、cpu 100%怎样定位
13、String a = "ab"; String b = "a" + "b";  a == b 是否相等，为什么     
14、int a = 1; 是原子性操作吗
15、可以用for循环直接删除ArrayList的特定元素吗？可能会出现什么问题？怎样解决              
16、新的任务提交到线程池，线程池是怎样处理
17、AQS和CAS原理
18、synchronized底层实现原理
18、volatile作用，指令重排相关
20、AOP和IOC原理
21、Spring怎样解决循环依赖的问题
22、dispatchServlet怎样分发任务的
22、描述一下Java异常层次结构。
    Error：错误，是程序无法处理的错误。比如OutOfMemoryError。
    Exception：异常，是程序本身可以处理的异常。NullPointerException、ArithmeticException、ArrayIndexOutOfBoundException
    Error和Exception继承Throwable。
    
31、什么是检查异常，不受检查异常，运行时异常？并分别举例说明。
    可查异常：编译器会检查它，当程序中出现这类异常，要么用try-catch捕获，要么用throws抛出，否则编译器不会通过，
    不受检查异常：编译器不要求强制处置的异常，包括运行时异常（RuntimeException）和错误（Error）。
    运行时异常：不受检查异常。

32、finally块一定会执行吗？
    一般情况下会执行。
    1）System.exit(0); 在try或catch块中，则不会执行。在执行finally之前虚拟机被停止。
    2）被设置为守护线程的内部代码的finally可能不会被执行。守护线程随着非守护线程的退出而退出，可能线程退出而还没执行到finally。

33、正常情况下，当在try块或catch块中遇到return语句时，finally语句块在方法返回之前还是之后被执行？
    finally中有return：先执行到try或catch中的return语句，然后跳转到finally中执行return，此时直接返回，不会再去执行try或catch中的return。
    finally中没有return：先执行到try或catch中的return语句，然后在跳转到finally块执行语句，然后再跳转回try或catch块执行return。

34、try、catch、finally语句块的执行顺序。
    1）finally一定最后执行。
    2）无异常：try执行，finally执行，finally之后的语句执行。
    3）有异常：
            catch能捕获：try中语句执行到异常时，跳转到catch中执行，最后执行finally中的语句，但是finally之后的语句不会被执行。
            catch不能捕获：try中语句执行到异常时，此时catch无法捕获，则交给jvm处理，但是finally中的语句还是会被执行。

33、Java中的参数传递时传值呢？还是传引用？
    传递值，引用也是值

33、对象引用类型分为哪几类？
    强、软、弱、虚

34、一个空Object对象的占多大空间？
    引用占内存+空对象占堆内存

35、Java中有没有指针的概念？
    java中没有指针，但java中有引用。
    基本类型，值就直接保存在变量中。
    引用类型，变量中保存的只是实际对象的地址，一般称为“引用”，引用指向实际对象，实际对象保存这内容。

6、怎么理解无界队列和有界队列？
    https://www.cnblogs.com/hujinshui/p/10342897.html
    https://my.oschina.net/u/3999718/blog/3007143
    有界队列：有固定大小的队列。
    无界队列：没有设置固定大小的队列，可以直接入队列，知道溢出，但不会超过Integer.MAX_VALUE。
8、什么是反射机制？
    在运行时获取类的属性和方法，并动态调用类的方法。
9、说说反射机制的作用。
    不用写死代码，可以动态配置代码。
10、反射机制会不会有性能问题？
    会有性能问题，不过不用在意，spring中大量使用反射。
11、List有哪些实现，如何实现的，如何使用它们？

Map有哪些实现， 如何实现的？说说HashMap底层数据结构

HashSet是如何实现的？HashMap,HashSet的区别？

HashMap是如何get、put、扩容的？key重复了怎么办? 是如何解决的?

如何Java的两个集合的交集、并集？

如何保证List、Set或者Map中元素的有序性？

List里的元素能不能重复？Set呢？List、Set中如果两次存放相同的对象或相同的key，会返回什么？是否发生异常？

1. 说说环境变量JAVA_HOME的作用？
    CLASSPATH: 类搜索路径. import java.util.*的时候, 编译器会去CLASSPATH路径下, 遍历子目录. 如果包在别处, 就要将路径添加到CLASSPATH中.
    JAVA_HOME: 指向jdk的安装目录. 
    PATH: 命令搜索路径.

2. Overload和Override的区别。Overload的方法是否可以改变返回值的类型？
    Overload: 重载. 
        必须改变参数列表(参数个数或类型);
        可以改变返回类型, 可以改变访问修饰符, 可以声明新的或更广的检查异常.
    Override: 重写
        参数列表已不能修改.
        返回类型一定不能修改.
        不能降低访问限制.
        不能抛出新的或者更广的异常.

3. 什么时候使用Object类中的clone()方法，clone() 和new 有什么区别。
    java中clone()和new都能创建对象.
    clone()不会调用构造方法; new会调用构造方法.
    clone()能快速创建一个已有对象的副本,即创建对象并且将已有对象中所有属性值克隆;new只能在JVM中申请一个空的内存区域,对象的属性值要通过构造方法赋值.

Java IO 主要的接口、实现？
    AutoCloseable：JDK7新添加的接口，对带资源的try语句提供了支持，可以自动执行资源关闭过程。
    Closeable：实现了Closeable接口的对象可以被关闭。JDK7开始Closeable拓展了AutoCloseable。在JDK7中，所有实现了Closeable接口的类也都实现了AutoCloseable接口。
    Flushable：实现了Flushable接口的类的对象，可以强制将缓存的输出写入到与对象关联的流中。flush()。
    Appendable：如果某个类的实例打算接收取自java.util.Formater的格式化输出，那么该类必须实现Appendable接口。
    Readable：如果一个类继承了readable接口并实现了read方法，我们就可以使用scanner类来进行操作。

什么是ByteArrayInputStream、ByteArrayOutputStream，如何使用？

什么是DataInputStream、、DataOutputStream，如何使用？

什么是ObjectInputStream、、ObjectOutputStream，如何使用？

什么是标准输入、输出流， 缓冲流？如何重定向标准输入流？
    标准输入流: InputStream is = System.in;
    标准输出流: PrintStream ps = System.out;
    缓冲流: 在读写数据时, 让数据在缓冲区能够减少系统实际对原属数据来源的存取次数, 因为一次能够做多个数据单位的操作.
        BufferedInputStream、BufferedOutputStream类和BufferedReader、BufferedWriter.
    重定向标准输入输出流:
        三个重定向方法:  static void setErr（PrintStream err）、Static void setIn（InputStream in）、Static void setOut（PrintStream out）
      ```
      //初始化一个PrintStream对象
      PrintStream ps = new PrintStream(new FileOutputStream("c:/myDoc/hello.txt"));
      //重定向标准输出流，重定向到上面指定的文件
      System.setOut(ps);
      //使用PrintStream对象向流中写信息
      System.out.print("测试一下，看重定向是否成功");
      System.out.println(new ReOut());
      //关闭流
      ps.close();
     ```

字节流和字符流有什么区别，如何使用？
    读写的时候，一个按字节读，一个按字符。
    读写文件和内容无关的一般选择字节流。

flush()方法的作用？什么时候需要执行flush？
    flush() 刷新缓冲区，仅刷新，并不会关闭流对象。
    close() 关闭流对象，在关闭之前会刷新该留。
    一般写操作，如果要查看是否写入，就要flush()，否则数据可能还在缓冲区。

什么是定时任务，如何使用TimerTask ？
    Timer是jdk提供的一个定时器工具，使用的时候会在主线程之外起一个单独的线程执行指定的计划任务，可以指定执行一次或者反复执行多次。
    TimerTask是一个实现了Runnable接口的抽象类，代表一个可以被Timer执行的任务。
    使用：
        1、new一个TimerTask的子类，重写run方法来指定具体的任务。
        2、new一个Timer类，Timer的构造函数里会挂起一个单独的线程来执行计划任务。
        3、调用schedule方法执行计划。
        4、结束线程，timer.cancel();
        ```
        public class TestTimer {
            public static void main(String args[]){
                System.out.println("About to schedule task.");
                new Reminder(3);
                System.out.println("Task scheduled.");
            }
            public static class Reminder{
                Timer timer;
                public Reminder(int sec){
                    timer = new Timer();
                    timer.schedule(new TimerTask(){
                        public void run(){
                            System.out.println("Time's up!");
                            timer.cancel();
                        }
                    }, sec*1000);
                }
            } 
        }
        ```
如何写一个自定义的注解？注解的使用范围有哪些？
    四种元注解：
        @Documented 是否将注解信息添加在java文档中
        @Retention  定义该注解的生命周期
                    RententionPolicy.SOURCE  在编译阶段丢弃。@Override, @SuppressWarnings都属于这类注解。
                    RententionPolicy.CLASS   在类加载的时候丢弃。
                    RententionPolicy.RUNTIME 始终不会丢弃。运行期也保留该注解，因此可以使用反射机制读取该注解的信息。自定义的注解通常使用这种方式。
        @Target     注解用在什么地方
        @Inherited  是否允许子类继承该注解

Java中的注解是如何工作的？
    当注解标注到某个类或者方法或者成员变量或者某个输入参数上的时候，一定有一个对应的机制来对注解标注的类、方法、成员变量和参数进行某些处理。
    对于@Override注解，它的用户就是JVM虚拟机，工作在字节码层面，在编译阶段进行检查，其处理机制主要是JVM内部处理。
    Spring中的@Service注解，Spring在启动IOC容器的时候会对每个没进行扫描，把所有标注@Component及其子注解如@Service的类进行Bean处理。

什么是枚举，是否可以继承？如何获取一个枚举类型里面的所有值？Java中的枚举是如何工作的？
    如果一个类的实例是有限且确定的，那么可以使用枚举类。
    ```
    enum Season{
　　    SPRING,SUMMER,FALL,WINTER;//默认public static final，这都是Season类的对象。
    }
    ```
    枚举类的对象默认都是 public static final。
    枚举类的构造器都是 private，所以无法在外部创建其实例，这也决定了枚举类实例的个数的确定性。
    enum 类不可被继承。（final修饰）
    enum 类无法继承其他类。（enum默认继承java.lang.Enum）
    https://www.cnblogs.com/xiangguoguo/p/9061678.html
    https://blog.csdn.net/weixin_37490221/article/details/86677274

    获取全部枚举值：
        YourEnumClass[] yourEnums = YourEnumClass.class.getEnumConstants();
        或
        YourEnumClass[] yourEnums = YourEnumClass.values();
    
    java中的枚举类是如何工作的：
        枚举就是一个特殊的类，枚举类的对象都是该枚举类的实例。
    
Java 文件等资源，打开了不关闭，会出现什么后果？
    资源必须写在finally块中保证关闭。因为finally块一定会执行。
    优雅的关闭：jdk7中提供了try-with-resource语法，外部资源的句柄对象实现了AutoCloasable接口即可。
               将外部资源的句柄对象的创建放在try关键字后面的括号中，当这个try-with-catch代码块执行完毕后，Java会确保外部资源的close方法被调用。
    https://gitbook.cn/books/5bff7d9934b2d414a8f76338/index.html

什么时候用assert？
    测试的时候，默认jvm没开启断言，assert isOpen = true;

int和Integer有什么别？
    基本数据类型与包装类：
    byte --> Byte
    short --> Short
    int --> Integer
    long --> Long
    float --> Float
    double --> Double
    char --> Character
    boolean --> Boolean

为什么要有包装类？
    java是面向对象的编程语言，基本类型并不具有对象的性质，为了让基本类型也具有对象的特征，就出现了包装类，将基本类型包装起来，使它具有了对象的性质，并且为其添加了属性和方法。
    当需要往ArrayList、HashMap中放东西时，基本数据类型是放不进去的，因为容器都是装objet的，这就需要这些基本的包装类了。
    包装类型将对象存在堆中，然后通过引用使用；基本数据类型直接将变量值存储在栈中。

什么是自动装箱、自动拆箱？
    将基本数据类型转换为包装类对象，这个过程叫做装箱；反之是拆箱。
    装箱和拆箱是在编译成class文件时自动加上的，因此又叫做自动装箱\拆箱。
    自动用valueOf()做装箱（Long.valueOf(100L)、Boolean.valueOf(true)）；自动用intValue、longValue、booleanValue做拆箱。

什么是Thread join、yeild？ 区别？
    join：
        t.join(timeout)方法会则是调用此方法的线程进入TIME_WAITING状态，知道线程t完成，此线程再继续。
        底层实现是通过wait(time)，到时间会自动唤醒。
    yeild：
        当一个线程调用yeild之后，会让出当前使用的CPU，让自己从运行态转为就绪态。

栈、队列的区别？双向队列？
    栈：
        先进后出，只有一头可进。
        Stack<String> staffs = new Stack<String>();
        staffs.push("a");//
        staffs.pop();// 出栈
        staffs.peek();// 取栈顶元素，并不会弹出
        staffs.search(obj);// 判断元素是否在栈中
        底层：动态增长的数组，方法使用synchronized修饰，线程安全。

    队列：先进先出，一头进另一头出。

    双向队列：可以在头尾插入和删除元素。

如何捕获正则表达式中的分组？

在 Queue 中 poll()和 remove()有什么区别？
    offer()和add()的区别：都是向队列中添加元素，如果满，add会抛出一个unchecked异常，offer则会返回false.
    peek()和element()的区别：都将在不移除的情况下返回队头，peek()在队列为空的时候返回null，element抛出异常。
    poll()和remove()的区别：都将移除并且返回队头，poll()在队列为空时返回null，而remove()会抛出异常。
    https://www.cnblogs.com/yuandluck/p/9476123.html

222、说说Xml、json的优缺点，分别有哪些现有的开源框架?
    xml比json更重量级。
    一般接口返回数据都是json，js可以用eval轻松解析json。
    开源框架jackson。

2. == 和 equals 的区别是什么？
    == 比较地址
    equals()交给开发者自己去定义比较规则，Object中比较地址，String继承自Object并重写了equals，比较值。基本类型包装类中比较值。

3. 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？
    hashCode() 和 equals()都可以由开发者重写。
    官方原则：1、两个对象equals相等，hashCode就要相等。
             2、两个对象hashCode相等，不一定要求equals相等。

5.java 中的 Math.round(-1.5) 等于多少？
    Math.round(-10.5)加0.5向下取整：-10
    Math.ceil(-10.2) 取大 -10
    Math.floor(-10.2) 取小 -11
    
6.String 属于基础的数据类型吗？
    String不属于基本数据类型。
    基本数据类型：byte、short、int、long、float、double、char、boolean
    byte: 1字节
    short: 2字节
    int：4字节
    long: 8字节
    float: 4字节
    double: 8字节
    char: 2字节

7.java 中操作字符串都有哪些类？它们之间有什么区别？
    String、StringBuilder、StringBuffer
    String是不可变类，被声明为final，所有属性也都是final，对String对象的操作都会产生一个新的String对象。线程不安全
    StringBuffer的操作在对象上操作。线程安全的可修改字符串序列。
    StringBuilder线程不安全，其余和StringBuffer一样。
    String、StringBuilder、StringBuffer底层是数组实现，JDK 9之前是char数组，之后是byte数组。
    StringBuffer的线程安全是通过在修改数据的方法上都加上synchronized关键字实现的。
    StringBuffer和StringBuilder都继承自AbstractStringBuilder。区别仅仅是方法上有无synchronized。
    字符串缓存：使用intern()方法可以将字符串缓存起来, JVM一般会缓存字符串字面量、字符串常量，即字符串常量池。
               永久代存在时候，字符串常量池在永久代中，其空间优先，基本不会被FullGC之外的垃圾收集照顾到。使用不但会有OOM。
               永久代一出之后，缓存池被放到了堆中，这样就避免了永久代被占满的问题。
               使用JVM参数-XX:+PrintStringTableStatistics可以打印字符串常量池（String table【https://www.jianshu.com/p/5524fce8b08f】）的大小。
               使用JVM参数-XX:StringTableSize=N设置字符串常量池的大小。
               Java 8 update 20中引入的字符串去重的特性，可不显示使用intern()，使用参数-XX:+UseG1GC -XX:+UseStringDeduplication，必须要使用G1垃圾回器。
               字符串去重会去查找那些未被处理的字符串，计算它们的hash值（如果它没在应用的代码中被计算过的话），然后再看是否有别的字符串的hash值和底层的char[]都是一样的。如果找到的话——它会用一个新字符串的char[]来替换掉现有的这个char[]。
               字符串缓存底层使用到了hash表StringTable，是一个固定大小的HashTable，基本你逻辑与java中HashMap相同，也使用拉链法解决碰撞。
    String 自身的演化：低版本的String是char数组来存数组的。java中的char是两个byte大小，拉丁语系的字符根本不需要太宽的char。
                      java 9中引入了Compact Strings的设计，使用byte数组加一个标识编码的coder（LATIN1、StringUTF16）来存储数据。
                      只要有一个字符需要两个以上byte存储，所有的字符都会使用两个byte。
    应用场景
      [A]在字符串内容不经常发生变化的业务场景优先使用String类。例如：常量声明、少量的字符串拼接操作等。如果有大量的字符串内容拼接，避免使用String与String之间的“+”操作，因为这样会产生大量无用的中间对象，耗费空间且执行效率低下（新建对象、回收对象花费大量时间）。
      [B]在频繁进行字符串的运算（如拼接、替换、删除等），并且运行在多线程环境下，建议使用StringBuffer，例如XML解析、HTTP参数解析与封装。
      [C]在频繁进行字符串的运算（如拼接、替换、删除等），并且运行在单线程环境下，建议使用StringBuilder，例如SQL语句拼装、JSON封装等。

8.String str="i"与 String str=new String("i")一样吗？
    不一样，第一个"i"存储在字符串常量池，第二个"i"存储在java堆。

9.如何将字符串反转？
    (1) for循环中str.charAt(i)
    (2) new StringBuilder(str).reverse()。StringBuffer也可以。
    (3) str.toCharArray()
    (4) str.getBytes()

10.String 类的常用方法都有那些？
    str.length()
    str.isEmpty()
    str.trim()
    str.toCharArray()
    str.getBytes()
    str.intern()
    str.compareTo()
    str.concat()
    str.contains()
    str.replace()
    str.split()
    str.indexof()

11.抽象类必须要有抽象方法吗？
    抽象类能继承一个普通类（或抽象类），实现多个接口。
    抽象类和普通类相比只是不能被实例化，只能作为子类的超类。
    抽象类是用来捕捉子类的通用特性的，被用来创建继承层级里子类的模板。
    可以有默认的方法实现。
    抽象类可以有构造方法。
    可以有main方法。
    不必须有抽象方法。
    ===接口===
    接口能实现多个其他接口。
    接口是抽象方法的集合，一个类实现了某个接口就必须实现抽象方法。
    接口抽象方法默认修饰符是public（可以不写），不能使用其他修饰符。
    java 8中接口可以包含具体的方法实现，方法实现必须default修饰。

12.普通类和抽象类有哪些区别？
    抽象类不能被实例化。
    抽象类可以有构造方法。
    抽象类可以有main方法。
    抽象类可以有抽象方法。

13.抽象类能使用 final 修饰吗？
    final修饰的类不能被继承，抽象类只有被继承才能使用。

15.java 中 IO 流分为几种？
    字节流：按8位传输。所有文件的村塾都是按字节（byte）存储。字节流可以处理任何类型的IO操作，包括二进制。
    字符流：字符流只能处理字符。包括Unicode字符（字节流不行）

16.BIO、NIO、AIO 有什么区别？  
    同步和异步：同步和异步关注的是消息通信机制。
               同步：发起一个调用，在没得到结果之前，该调用就不返回，但是一旦调用返回，就得到返回值了。调用者主动等待这个调用的结果。
               异步：调用发出后，不管有没有得到结果，该调用直接返回。被调用者其后会通知调用者。
    阻塞与非阻塞：阻塞与非阻塞关注的是程序在等待调用结果时的状态。
                阻塞：调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才返回。
                非阻塞：调用不能立刻得到结果之前，该调用不会阻塞当前线程。
    select与epoll、poll区别：
                
    BIO(同步阻塞IO)：
            服务端：由一个独立的线程负责监听客户端的连接，它每次接收到客户端的连接请求后都会为该客户端创建一个新的线程，这个线程负责与对应的客户端进行数据收发。
            客户端：向服务端发起请求，如果没有响应则会等待或收到拒绝请求。
    AIO(同步非阻塞New IO或Non-Block IO)
            通道Channel：对数据的读写都要通过Channel。
            多路复用器Selector：Selector提供选择已经就绪的任务的能力，selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或写时间，
                               这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的IO操作。
                               一个Selector可以同时轮询多个Channel，JDK使用epoll()代替了传统的select实现。只要一个线程负责Selector的轮询，就可以接入
                               成千上万的客户端。
                               “负责代替应用查询中所有已注册的通道到操作系统中进行IO事件轮询、管理当前注册的通道集合，定位发生事件的通道等操作”
            代码：
            server:
                ...
                // 打开通道
                ServerSocketChannel server = ServerSocketChannel.open();
                // 设为非阻塞
                server.configureBlocking(false);
                // 绑定端口
                server.bind(new InetSocketAddress(10086));
                // 获得一个selector
                Selector selector = Selector.open();
                // 将通道管理器和该通道绑定，并为该通道注册SelectionKey.OP_ACCEPT事件，注册时间后，
                // 当该事件到达时，selector.select()就会返回，如果该事件没有到达，selector.select()会一直阻塞
                server.register(selector, SelectionKey.OP_ACCEPT)
                Systom.out.pringln("等待客户端连接");

                // 采用轮询的方式监听selector上是否有需要处理的事件，如果有，则进行处理
                while(true){
                    // 当注册的事件到达时，方法返回，否则，该方法会一直阻塞。
                    selector.select();
                    // 获得selector中选中的项的迭代器，选中的项为注册的事件
                    Itreator<SelectionKey> ite = selector.selectedKeys().iterator();
                    while(ite.hashNext()){
                        SelectionKey key = (SelectionKey)ite.next();
                        // 删除已选的key，以防重复处理
                        ite.remove();

                        if(key.isAcceptable()){ // 客户端连接事件
                            ServerSocketChannel serverSocketChannel = (ServerSocketChannel)key.channel();
                            // 获得和客户端连接的通道
                            SocketChannel channel = serverSocketChannel.accept();
                            // 设为非阻塞
                            channel.configureBlocking(false);
                            // 在这里可以给客户端发送信息
                            channel.write(ByteBuffer.wrap(new String("客户端你好").getBytes("utf-8")));
                            // 在客户端连接成功之后，为了可以接收到客户端的信息，需要给通道设置读的权限。
                            channel.register(selector, SelectionKey.OP_READ);
                        }else if(key.isReadable()){ // 获得可读事件
                            // 服务器可读信息：得到事件发生的Socket通道
                            SocketChannel channel = (SocketChannel)key.channel();
                            // 创建读取的缓冲区
                            ByteBuffer buffer = ByteBuffer.allocate(512);
                            channel.read(buffer);
                            byte[] data = buffer.array();
                            String msg = new String(data).trim();
                            System.out.println("接收到客户端发来的数据：" + msg);
                        }
                    }
                }
                ...
                将新接入的客户端连接注册到Reactor线程的Selector上，监听读操作。
                异步读取客户端消息到缓冲区。
                将应答消息编码为Buffer，调用SocketChannel的write将消息异步发送给客户端。
    AIO(异步非阻塞IO)：
                采用“订阅-通知”模式：即应用程序向操作系统注册IO监听，然后继续做自己的事。当操作系统发生IO事件，并且准备好数据后，在主动通知应用程序，触发相应的函数。

17.Files的常用方法都有哪些？
    createNewFile() 创建新文件
    mkdirs() 创建新的目录，若父目录不存在，会自动创建
    renameTo(File dest)重命名文件
    isFile()判断是否是文件
    isDirectory() 判断是否是目录
    exists() 判断文件或者目录是否存在
    canRead() 判断文件是否可读
    canWrite() 判断文件是否可写
    isHidden() 判断文件是否隐藏

    getAbsolutePath() 获取绝对路径
    getPath()获取相对路径
    getName()获取文件或目录
    length() 获取文件大小
    lastModified() 获取文件最后一次修改的时间
    list()获取路径表示目录下的所有文件和目录名称
    list(FilenameFilter filter) 获取满足过滤器FilenameFilter条件的所有目录或文件
    listFiles() 获取路径表示目录下的所有文件和目录对象
    listFiles(FilenameFilter filter) 获取满足过滤器FilenameFileter条件的所有目录或文件对象

74.throw 和 throws 的区别？
    throws 是用来声明一个方法可抛出的所有异常信息，throws是将异常声明但不处理，而是将异常往上传，传给调用者。
    throw 抛出一个具体的异常类型。
    一个异常要么向上抛（throws）给调用者去处理，要么自身捕获（try{}catch(Exception e){}），自己去处理
75.final、finally、finalize 有什么区别？
    final修饰的类不能被继承。
    final修饰的成员变量要赋值初始化或在构造方法中赋值。
    final修饰的局部变量必须要赋值初始化，并且不能修改。
    final修饰的方法会被JVM优化。
    
    GC前对象会调用finalize，可在finalize中将自身（this）赋值给其他变量从而起死回生。
    一个对象被GC之前会调用finalize()，可以重写finalize()让即将被清理的对象起死回生（Person.person = this;）
    finalize()至多由GC执行一次，用户可以手动调用对象的finalize(),但并不影响GC对finalize的行为。
76.try-catch-finally 中哪个部分可以省略？
    1) finally可以省略。finally块最终都会执行。
    2) 关闭资源的操作放到finally中，因为try块中抛出异常后不会继续向下执行。程序可能无法到达try的尾部，但一定会到达finally。
    3) 不要捕获Throwable，Throwable是所有exceptions和errors的父类。不仅捕获所有异常而且捕获所有错误。
       这些错误由JVM抛出，用来表明不打算应用程序处理的严重错误。比如OutOfMemoryError和StackOverflowError。
       折中方法是在底层捕获Throwable，其他层级捕获Exception。
    4) try-with-resource 自动关闭外部资源。资源句柄要实现AutoCloseable接口。
        try (FileInputStream inputStream = new FileInputStream(new File("test"))) {
            System.out.println(inputStream.read());
        } catch (IOException e) {
            throw new RuntimeException(e.getMessage(), e);
        }

77.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？
    照样执行

78.常见的异常类有哪些？
    Throwable是所有异常或错误的超类。
    Error是Throwable的子类。
    Exception是Throwable的子类。
        异常分为两大类：
            Checked异常：非Runtime异常。用户代码显式抛出的异常。要么throws exception，要么try...catch捕获。
                    f(){
                        int a = 123;
                        if(a = 1233){
                            throw new NullPointerException();
                        }
                    }
                    f()的调用者要么向上抛异常(throws)，要么处理异常（try..catch）。
            Runtime异常：所有RuntimeException类及其子类的实例被称为Runtime异常。不可预见的异常，在运行时候抛出。
    常见运行时异常：
        ClassCastException(类转换异常)：
            instanceof：判断一个对象是否为一个类的实例。obj instanceog Class。
                        1、obj必须为引用类型，不能是基本类型。
                        2、obj为null返回false。
                        3、obj为类或接口的直接或间接子类，返回true。
                        4、
                            ArrayList arrayList = new ArrayList();
                            arrayList instanceof List;  // true
                            List list = new ArrayList();
                            list instanceof ArrayList; // true
        ArrayIndexOutOfBoundsException(数据越界异常)
                访问不不在的数组索引，或设置了负数索引。
        NullPointerException(空指针异常)
                public class mainTest {
                    public static void main(String[] args)  {
                        Person person = new Person(2,"saisai");
                        person = null;
                        System.out.println(person.getAge());
                    }
                }
                使用前判断是否为空（null）。
                亦可使用Optional优雅地决绝判断null的多层嵌套。
        ArrayStoreException(数据存储异常)
        BufferOverflowException(缓冲溢出异常)
        
什么是lambda表达式、函数式编程？
    在java8中，可以优雅的把 “一块代码” 赋给一个变量，而“这块代码”，或者说“这个被赋给一个变量的函数”，就是一个Lambda表达式。
    aBlockOfCode = public void doSomeShit(String s){
        System.out.println(s);
    }
    ====>
    aBlockOfCode = (s)->System.out.println(s);
    所有的Lambda的类型都是一个接口，而Lambda表达式本身，也就是“那段代码”，需要是这个接口的实现。
    Lambda本身就是一个接口的实现。
    给aBlockOfCode加上一个类型：
    interface MyLambdaInterface(){
        void doSomeShit(Strinf s);
    }
    函数式接口：只有一个接口函数需要被实现的接口类型。加上声明@FunctionalInterface，这样别人就无法在里面添加新的接口函数了。
    得到一个完整的Lambda表达式声明：
    MyLambdaInterface aBlockOfCode = (s)->System.out.println(s);
    由于Lambda可以直接赋值给一个变量，我们就可以直接把Lambda作为参数传给函数，而传统的Java必须有明确的接口实现的定义，初始化才行。
    public static void enact(MyLambdaInterface myLambda, String s){
        myLambda.doSomeShit(s);
    }
    enact(s->System.out.println(s), "hello world");
    https://www.zhihu.com/question/20125256/answer/324121308

Java.util.function包里面的 Supplier/Consumer/Predicate/BiFunction 分别是什么含义？


Unsafe
    https://zhuanlan.zhihu.com/p/56772793
    Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源。
    但由于Unsafe类使java拥有了类似C指针一样操作内存空间的能力，存在风险。 
    主要功能：
    1）数组相关
        返回数组元素内存大小。
        返回数组元素偏移地址。
    
    2）内存屏障
        禁止load、store重排序
    
    3）系统相关
        返回内存页大小
        返回系统指针大小
    
    4）线程调度
        线程挂起、恢复
        获取、释放锁
        AbstractQueuedSynchronizer类就是通过调用LockSupport.park()和LockSupport.unpark()来实现线程的阻塞和唤醒的。
        而LockSupport的park、unpark方法实际是调用Unsafe的park、unpark方式来实现的。

    5）内存操作
        分配、拷贝、扩充、释放堆外内存
        设置、获得给定地址中的值
    
    6）CAS
        java.util.concurrenet.automic包的原子类使用cas更新。

    7）Class相关
        动态创建类（普通类&匿名类）
        获取field的内存地址偏移量
        检测、确保类初始化

    8）对象操作
        获取对象成员属性在内存偏移量
        非常规对象实例化
        存储、获取指定偏移地址的变量值（包含延迟生效、volatile语义）