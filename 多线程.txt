1、多线程的几种实现方式，什么是线程安全。什么情况下需要考虑其线程安全问题？
    线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。
    不会出现数据不一致或者数据污染。
    多个线程会并发修改资源的时候会考虑线程安全问题。

2、volatile的原理，作用，能代替锁么。
    可见性：指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。一个线程修改的结果，另一个线程马上就能看到。
            用volatile修饰的变量，就具有可见性。不允许线程内部缓存和重排序，即直接修改内存。
            不能保证原子性。
    原子性：不可分割的操作具有原子性。原子操作：a=0；非原子操作 a++，即a=a+1；
    有序性：指按照代码的顺序执行。为了性能优化，编译器、处理器会将代码重排序。

3、画一个线程的生命周期状态图。
    创建
    可运行
    运行
    阻塞
    死亡

4、sleep(timeout)和sleep(0)的区别。
    timeout>0，线程将会阻塞。
    timeout=0，系统将会找一个优先级更高的线程运行，如果找不到则会继续执行当前线程，就当什么都没发生。

5、synchronized的原理是什么，一般用在什么地方(比如加在静态方法和非静态方法的区别，静态方法和非静态方法同时执行的时候会有影响吗)，解释以下名词：重排序，自旋锁，偏向锁，轻
    量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁。
    重排序：为了性能，会对指令进行重排序。
    自旋锁：当一个线程尝试获取锁的时候，如果锁被占用，则会不断尝试直到获取锁。
    偏向锁：
    轻量级锁：
    重量级锁：
    可重入锁：获取锁之后还可以再次获取锁。
    公平锁：通过排队的方式，可以让每一个线程获取到锁。
    非公平锁：每次获取锁的过程都是重新竞争，会有线程永远获取不到锁。
    乐观锁：更新数据的时候判断是否数据被修改过。可以使用版本号机制加CAS实现。
    悲观锁：操作一个数据之前先上锁。
6、用过哪些原子类，他们的原理是什么。
    1）原子更新基本类型
        AtomicBoolean：原子更新布尔值
        AtomicInteger：原子更新整型
        AtomicLong：原子更新长整型
        int addAndGet(int delta)：以原子的方式将输入的数值与实例中的值相加，并返回结果。
        boolean compareAndSet(int expect, int update)：如果输入的值等于预期值，则以原子方式将该值设置为输入的值。
        int getAndIncrement()：以原子的方式将当前值加1。
        void lazySet(int newValue)：最终会设置成newValue，使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。
        int getAndSet(int newValue)：以原子的方式设置newValue，并返回旧值。
        Atomic包里的类基本都是使用Unsafe下的CAS方法实现的，Unsafe只提供了三种CAS方法：
        compareAndSwapObject、compareAndSwapInt、compareAndSwapLong其他类型都是转成这三种类型再使用对应的方法去原子更新的。
    2）原子更新数组
        AtomicIntegerArray：原子更新整型数组的元素
        AtomicLongArray：原子更新长整型数组里的元素
        AtomicReferenceArray：原子更新引用类型数组里的元素
        get(int index)：获取索引为index的元素值
        compareAndSet(int i, E expect, E update)：如果当前值等于预期值，则以原子方式将数组位置i的元素设置为update值。
    3）原子更新引用类型
        AtomicReference：原子更新引用类型。
        AtomicMarkableReferce：原子更新带有标记的引用类型。
    4）原子更新字段类
        AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。
        AtomicLongFieldUpdater：原子更新长整型字段的更新器。
        AtomicStampedFieldUpdater：原子更新带有版本号的引用类型。
        AtomicReferenceFieldUpdater：原子更新引用类型的字段（更新的字段必须用public volatile修饰）。

7、JUC下研究过哪些并发工具，讲讲原理。
    java5.0提供了java.util.concurrent（简称JUC）包，此包中增加了并发编程中常用的工具类。
    用过线程池吗，如果用过，请说明原理，并说说newCache和newFixed有什么区别，构造函数的各个参数的含义是什么，比如coreSize，maxsize等。
    线程池的关闭方式有几种，各自的区别是什么。
    假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。
    用三个线程按顺序循环打印abc三个字母，比如abcabcabc。

8、ThreadLocal用过么，用途是什么，原理是什么，用的时候要注意什么。
    ThreadLocal为每个线程创建一个副本，没有线程间变量共享。
    副作用：脏数据和内存泄漏（复用线程脏数据会变多导致内存泄漏 ）。
        线程复用会产生脏数据，由于线程池会复用Thread对象，那么与Thread绑定的类的静态属性ThreadLocal变量也会被重用。
        如果在实现线程的run()方法体内不显式调用remove()清除与线程相关的ThreadLocal信息，
        那么倘若下一个线程不调用set()设置初始值，就可能get()到重用的线程信息，包括ThreadLocal所关联的线程对象的value值。

9、如果让你实现一个并发安全的链表，你会怎么做。
    解决方案：
    1）任何集合类都可以通过使用同步包装器编程线程安全的：
        List<E> synchArrayList = Collections.synchronizedList(new ArrayList<E>());
        Map<K,V> synchMap = Collections.synchronizedList(new HasMap<K,V>());
        原理在方法上加锁synchronized，提供线程安全的访问。
        但是遍历的时候还是要加锁：
        List list = Collections.synchronizedList(new ArrayList());
            ...
        synchronized (list) {
            Iterator i = list.iterator(); // Must be in synchronized block
            while (i.hasNext())
                foo(i.next());
        }
        Iterator<E> iterator(); 这个没加锁.
        使用同步包装器适合不需要使用Iterator\对性能要求不高的情况.
    2）线程安全和不安全集合
        线程安全集合：
            Vector、HashTable
            CopyOnWriteArrayList、CopyOnWriteArraySet
            ConcurrentHashMap、ConcurrentSkipListSet

        线程不安全集合：
            ArrayList、LinkedList、HashMap、HashSet、TreeMap、TreeSet
            
        JUC包中的Queue实现类：
            ArrayBlockingQueue是数组实现的线程安全的有界的阻塞队列。
            LinkedBlockingQueue是单向链表实现的(指定大小)阻塞队列，该队列按 FIFO（先进先出）排序元素。
            LinkedBlockingDeque是双向链表实现的(指定大小)双向并发阻塞队列，该阻塞队列同时支持FIFO和FILO两种操作方式。
            ConcurrentLinkedQueue是单向链表实现的无界队列，该队列按 FIFO（先进先出）排序元素。
            ConcurrentLinkedDeque是双向链表实现的无界队列，该队列同时支持FIFO和FILO两种操作方式。

    https://blog.csdn.net/xingjiarong/article/details/48046751

9-2、 ArrayList迭代删除
    ArrayList底层是数组实现, 使用remove(index)删除元素的时候, 步骤:
        1) 将i之后的所有元素前进一位, 数组最后的元素置为null.
    安全删除:
        1) 所有可以使用倒叙遍历删除.
        2) 每次循环都要重新获取size()并且i--.
        3) 使用Iterator迭代的时候使用迭代器的删除,ite.remove();

9-3、 迭代器
    迭代器提供一种方法对一个容器对象中的各个元素进行访问, 而又不暴露该对象容器的内部细节.
    因为容器的内部结构不同,很多时候可能不知道怎样去遍历一个容器的元素, 所以引入了迭代器模式.
    java.util.Iterator是接口。ArrayList等集合中有内部类实现了此接口。
    Iterator<String> listIt = list.iterator();
         while(listIt.hasNext()){
             System.out.println(listIt.next());
         }
    }
    foreach语法同样是由Iterator实现的：
    for (String string : list) {
        System.out.println(string);
    }
    https://www.cnblogs.com/zyuze/p/7726582.html
    https://blog.csdn.net/qq_30310607/article/details/82347807
    https://blog.csdn.net/layman1024/article/details/76103793

9-4、快速失败机制
    集合中有当前版本号modCount，每次修改（增、删）集合后版本号（expectModCount）都会加1，两个线程对集合进行操作时，若其中某一个线程
    通过Itreator遍历集合时，改集合的内容被其他线程所改变，则会抛出ConcurrentModificationException异常。

    当调用了ArrayList.add()或者ArrayList.remove()时候，只更新了modCount的状态，而迭代器中的exceptedModCount未同步，因此才会导致再次
    调用Itreator.next()方法时抛出异常，但是调用Iterator.remove()中同步了exceptedModCount的值，所以单反下次再调用next()的时候，不会异常。

10、有哪些无锁数据结构，他们实现的原理是什么。
    CAS（compare-and-swap）比较交换。
    java.util.concurrent.atomic包下的原子类是使用CAS.
    cas是使用Unsafe 提供的navive方法实现的。

11、讲讲java同步机制的wait和notify。
    java的wait和notify的通知机制可以用来实现线程间通信。wait表示线程的等待，调用该方法导致线程阻塞，直至另一线程调用notify或notifyall方法
    才可令其继续执行。经典的生产者、消费者模式即是使用wait/notify机制得以完成。

    wait/notify的调用必须处于锁获取时。
    每个对象都有自己的等待队列和阻塞队列，线程A调用wait后，线程A让出锁，自己进入等待状态，同时加入锁对象的等待队列。
    线程B获取锁后，调用notufy方法通知锁对象的等待队列，使得线程A从等待队列进入阻塞队列。
    线程A进入阻塞队列后，直至线程B释放锁后，线程A竞争得到锁继续从wait()方法后执行。

12、CAS机制是什么，如何解决ABA问题。
    加时间戳，AtomicStampedReference通过包装[E,Integer]的元组来对对象标记版本加stamp，从而避免ABA问题。

13、多线程如果线程挂住了怎么办。

14、countdowlatch和cyclicbarrier的内部原理和用法，以及相互之间的差别(比如countdownlatch的await方法和是怎么实现的)。
    CountDownLatch：
        允许一个或多个线程等待直到在其他线程中一组操作执行完成。
    CyclicBarrier:
        循环屏障，允许一组线程相互等待直到所有线程都到达一个公共的屏障点。
    CountDownLatch 是一次性的，CyclicBarrier 是可循环利用的
    ```
    public class CountDownLatchDemo implements Runnable{
        static final CountDownLatch latch = new CountDownLatch(10);
        static final CountDownLatchDemo demo = new CountDownLatchDemo();
        @Override
        public void run() {
            // 模拟检查任务
            try {
                Thread.sleep(new Random().nextInt(10) * 1000);
                System.out.println("check complete");
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                //计数减一
                //放在finally避免任务执行过程出现异常，导致countDown()不能被执行
                latch.countDown();
            }
        }
        public static void main(String[] args) throws InterruptedException {
            ExecutorService exec = Executors.newFixedThreadPool(10);
            for (int i=0; i<10; i++){
                exec.submit(demo);
            }
            // 等待检查
            latch.await();
            // 发射火箭
            System.out.println("Fire!");
            // 关闭线程池
            exec.shutdown();
        }
    }
    ```
15、对AbstractQueuedSynchronizer了解多少，讲讲加锁和解锁的流程，独占锁和公平所加锁有什么不同。
    ReentranLock、Semaphore、CountDownLatch等用到了AQS类锁提供的队列同步器。
    AQS是一个Java提供的底层同步工具类，用一个int型的变量表示同步状态，并提供了一系列的CAS操作来管理这个同步状态。
    AQS是一个双端队列，遵循FIFO原则，主要作用是用来存放在锁上阻塞的线程，当一个线程尝试获取锁的时候，如果已经被占用，那么当前线程就会被构造成一个Node节点加入到同步队列的尾部，
    队列的头节点是成功获取锁的节点，当头节点线程释放锁时，会唤醒后面的节点并释放当前头结点的引用。
    1）独占锁的获取和释放：
        获取:
        1、尝试获取锁，成功则返回，失败则下一步
        2、将当前线程构造成一个Node节点，并利用CAS将其加入到同步队列尾部，然后该节点对应到线程进入自旋状态。
        3、自选时，首先判断其前驱节点释放为头节点 & 是否成功获取同步状态，两个条件都成立，则将当前线程的节点设置为头节点，如果不是，则利用LockSupport.part(this)将当前线程挂起，等待被前驱节点唤醒。
        释放：
        1、获取当前节点的下一个节点
        2、利用LockSupport.unpark(currentNode.next.thread)唤醒后继节点。
    2）共享锁的获取和释放
        获取：
        1、获取同步状态，如果返回值>=0，则说明同步状态（state）有剩余，获取锁成功直接返回。
        2、如果返回值<0，说明获取同步状态失败，向队列尾部添加一个共享类型的Node节点，随即该节点进入自旋状态。
        3、自旋时，首先检查前驱节点释放为头节点 & 同步状态是否>=0
        4、如果是，则说明当前节点可执行，同时把当前节点设置为头节点，并且唤醒所有后继节点；如果否，则利用LockSupport.unpark(this)挂起当前线程，等待被前驱节点唤醒。
        释放：
        1、调用releaseShared(arg)方法释放同步状态
        2、如果释放成功，则遍历整个队列，利用LockSupport.unpark(nextNode.thread)唤醒所有后继节点
    独占锁和共享锁在实现上的区别：
        1、独占锁的同步状态值为1，即同一时刻只能有一个线程获取同步状态。
        2、共享锁的同步状态>1，取值由上层组件确定。
        3、独占锁队列中头节点运行完成后释放它的直接后继节点。
        4、共享锁队列中头节点运行完成后释放它后面的所有的节点。
        5、共享锁中会出现多个线程（即同步队列中的节点）同时成功获取同步状态的情况。
    重入锁
        ReentrantLock重入锁：判断上次获取的线程是否为当前线程，如果是则可再次进入临界区，如果不是，则阻塞。
    读写锁：
        可以共享读，但只能有一个写，读读不互斥，读写互斥，写写互斥。
        Java提供了一个基于AQS的读写锁实现ReentrantReadWriteLock。原理：将同步变量state按照高16位和低16位进行拆分，高16位表示读锁，低16位表示写锁。

16、使用synchronized修饰静态方法和非静态方法有什么区别。
    statc方法属于类方法，它属于类，synchronized修饰的static方法属于类的的锁；非static方法获取到的锁属于对象的锁。
    它们之间不会产生互斥。

17、简述ConcurrentLinkedQueue和LinkedBlockingQueue的用处和不同之处。

18、导致线程死锁的原因？怎么解除线程死锁。

19、非常多个线程（可能是不同机器），相互之间需要等待协调，才能完成某种工作，问怎么设计这种协调方案。

20、用过读写锁吗，原理是什么，一般在什么场景下用。


21、开启多个线程，如果保证顺序执行，有哪几种实现方式，或者如何保证多个线程都执行完再拿到结果。

22、延迟队列的实现方式，delayQueue和时间轮算法的异同。
23、Java编程写一个会导致死锁的程序
    1）两个线程，两个锁。
    2）A线程先获取lock_1，然后sleep(N)，再获取lock_2；线程B先获取lock_2，然后sleep(N)再获取lock_1。
    3）A、B线程相互等待锁。

24、LockSupport和Unsafe
    LockSupport定义了一组公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能，而LockSupport也因此成为了构建同步组件的基础工具。
    LockSupport.part() 阻塞当前线程。
    LockSupport.unpark() 唤醒处于阻塞状态的线程。
    LockSupport.parkNanos(long nanos) 阻塞当前线程，超时返回，阻塞时间最长不超过nanos纳秒。
    LockSupport.parkUntil(long deadline) 阻塞当前线程，直到deadline时间点。

    LockSupport的park和unpark方法都是通过sun.misc.Unsafe类的park和unpark方法实现。

26、常用的线程池模式以及不同线程池的使用场景

27、newFixedThreadPool此种线程池如果线程数达到最大值后会怎么办，底层原理。

28、多线程之间通信的同步问题，synchronized锁的是对象，衍伸出和synchronized相关很多的具体问题，例如同一个类不同方法都有synchronized锁，一个对象是否可以同时访问。或者一个类的static构造方法加上synchronized之后的锁的影响。

29、了解可重入锁的含义，以及ReentrantLock 和synchronized的区别
    可重入锁：若线程的某个方法获取到锁之后，那么在该方法中可以再次获取锁。

30、同步的数据结构，例如concurrentHashMap的源码理解以及内部实现原理，为什么他是同步的且效率高

31、atomicinteger和volatile等线程安全操作的关键字的理解和使用
    volatitle：
        线程对变量会有私有拷贝，volatitle修饰的变量保证其他线程读取的是当前已修改的值。
    atomicintger：原子类

33、分析线程池的实现原理和线程的调度过程
34、线程池如何调优
35、线程池的最大线程数目根据什么确定
36、什么是竞态条件？ 举个例子说明。
    当两个线程竞争同一个资源时，如果对资源的访问顺序敏感，就称为竞态条件。
    如果有个add()方法，jvm将其视为多条指令，多个线程可能交叉执行指令，那么add()方法就是临界区。
    在临界区中使用适当的同步就可以避免竞态条件。

37、volatile
    volatile 修饰符的有过什么实践？
    volatile 类型变量提供什么保证？
        可见性。
    能创建 volatile 数组吗？
        能，只不过只是一个指向数组的引用，而不是整个数组，如果改变了引用指向的数组，将会受到volatile的保护，但是如果多个线程同时改变数组的元素，volatile关键字就不能起到保护的作用。
    transient变量有什么特点？
        transient修饰的变量不被序列化。
38、多线程
    Vector, SimpleDateFormat 是线程安全类吗
        Vector:
            Vector底层类似ArrayList，都是数组实现的；Vector线程安全，使用synchronized保证线程安全。
        SimpleDateFormat：
            文本->日期；日期->文本的转化
            Date date = new Date();
            String strDateFormat = "yyyy-MM-dd HH:mm:ss";
            SimpleDateFormat sdf = new SimpleDateFormat(strDateFormat);
            System.out.println(sdf.format(date));

            线程不安全
    什么 Java 原型不是线程安全的
        long、double不是线程安全的。
        对于volatile 修饰的long和double，读写必须为原子的。
        但是规范没有规定怎么去实现，现今的虚拟机都是把32位作为原子性操作。
        但是对于64位确没有，因此64位虚拟机操作long和double时，会出现两次写操作，这就造成了错位可能，因此在64位上操作共享的long和double时，必须实现同步操作。
    
    哪些集合类是线程安全的
        线程安全：
            Vector：底层同ArrayList都是数组实现，使用synchronized确保线程安全。
            HashTable：底层同HashMap都是数组加链表实现，使用synchronized确保线程安全。
            StringBuffer：可变类，在原对象上进行操作，使用synchronized确保线程安全。

    多线程中的忙循环是什么
    线程和进程有什么区别？进程间如何通讯，线程间如何通讯

    什么是多线程环境下的伪共享（false sharing）
    
    同步和异步有何异同，在什么情况下分别使用他们？举例说明
        如果数据要在多线程间共享，那么就必须同步。
        如果调用一个功能需要花费很长时间才能取得结果，就应该异步。
    
    Current
    ConcurrentHashMap 和 Hashtable的区别
        Hashtable 底层使用数组和链表，用synchronized保证线程安全。
        ConcurrentHashMap 底层是数组加链表，刚开始使用分段加锁的方式确保线程安全，后来改为CAS。

    CyclicBarrier 和 CountDownLatch有什么不同？各自的内部原理和用法是什么
        CyclicBarrier:
            可以让一组线程等待至某个状态之后再全部同时执行，当所有线程被释放之后，CyclicBarrier可以被重用。
            CyclicBarrier cyclicBarrier = new CyclicBarrier(10); // 初始化10个线程
            cyclicBarrier.await(); // 每个线程执行到此处就等待。可以加延迟（规定时间未到达cyclibarrier的线程会排异常，就不再等你。并继续执行后面的任务）。
            当所有线程到达barrier时候，随机选一个执行runnable:
                CyclicBarrier cyclicBarrier = new CyclicBarrier(10, new Runnable(){
                    ...
                });
            
        CountDownLatch:
                CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。
                例如：应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。

    Semaphore的用法
        Semaphore是java8中juc并发包下提供的一个类。
        可以控制某个资源被同时访问的任务数，通过acquire()获取一个许可，release()释放一个许可。
        如果被同时访问的任务数已满，则其他任务进入等待状态。直到有一个任务被release掉，它才能得到许可。

        // 允许5个线程同时访问
        final Semaphore semp = new Semaphore(5);
        semp.acquire(); // 获得许可 
        semp.release(); // 释放许可

    Thread
    调用start()方法时会执行run()方法，为什么不能直接调用run()方法
    yield()、sleep()、join()、wait()、notify()
        yield()：
        sleep()
        join()
        wait()和notify()
        stop():
    Java 中如何停止一个线程
        stop()、interrupt()、或这其他方式实现interrupt()

    stop() 和 suspend() 方法为何不推荐使用
        stop() 粗暴的终止线程，结果不可预期。
        suspend()和resume()配合使用，suspend()挂起一个持有锁的线程，锁仍然占用，只有调用resume()才会取消挂起，如果resume()在suspend()之前调用就会死锁。
    

    如何强制启动一个线程
        t.join()方法阻塞调用此方法的线程(calling thread)进入 TIMED_WAITING 状态，直到线程t完成，此线程再继续。

    如何让正在运行的线程暂停一段时间
        sleep()

    什么是线程组，为什么在Java中不推荐使用？
        线程组表示一组线程的集合，线程组也可以包含其他线程组，线程执行完就会被回收。
        ThreadGroup tg = new ThreadGroup("我是线程组");
        MyThread my = new MyThread();
        Thread t1 = new Thread(tg, my, "线程1");
        Thread t2 = new Thread(tg, my, "线程2");
        线程组并没有提供太多有用的功能，而它们提供的许多功能还都是有缺陷的。我们最好把线程组看作是一个不成功的试验，你可以忽略掉它们，就当它们根本不存在一样。如果你正在设计的一个类需要处理线程的逻辑组，或许就应该使用线程池executor。

    你是如何调用 wait（方法的）？使用 if 块还是循环？为什么
        在synchronized块中，死循环，防止虚假唤醒。
        wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。

    生命周期
    线程状态，BLOCKED 和 WAITING 有什么区别
        waitting是等待notify唤醒。
        blocked是在运行中获取锁的时发现锁不可用，进入阻塞，知道锁可用。

    画一个线程的生命周期状态图

    线程池ThreadPool

    线程池是什么？为什么要使用它
        线程池是一种多线程处理形式，任务放到队列，多个线程同时存在。并在有任务的时候能够即时处理，处理完任务后可以复用线程，没任务的时候也线程池中也会有线程。
        创建线程消耗时间以及cpu性能，如果有任务才去创建线程就会来不及，不如未雨绸缪，先创建好。
        线程池还能复用线程。
        还能控制线程数量。

    如何创建一个Java线程池

    ThreadPool用法与优势

    提交任务时，线程池队列已满时会发会生什么

    newCache 和 newFixed 有什么区别？简述原理。构造函数的各个参数的含义是什么，比如 coreSize, maxsize 等

    线程池的实现策略

    线程池的关闭方式有几种，各自的区别是什么

    线程池中submit() 和 execute()方法有什么区别？

    线程调度

    Java中用到的线程调度算法是什么
    什么是多线程中的上下文切换
    你对线程优先级的理解是什么
    什么是线程调度器 (Thread Scheduler) 和时间分片 (Time Slicing)
    线程同步

    请说出你所知的线程同步的方法
    synchronized 的原理是什么
    synchronized 和 ReentrantLock 有什么不同
    什么场景下可以使用 volatile 替换 synchronized
    有T1，T2，T3三个线程，怎么确保它们按顺序执行？怎样保证T2在T1执行完后执行，T3在T2执行完后执行
    同步块内的线程抛出异常会发生什么
    当一个线程进入一个对象的 synchronized 方法A 之后，其它线程是否可进入此对象的 synchronized 方法B
    使用 synchronized 修饰静态方法和非静态方法有什么区别
    如何从给定集合那里创建一个 synchronized 的集合
    锁

    Java Concurrency API 中 的 Lock 接口是什么？对比同步它有什么优势
    Lock 与 Synchronized 的区别？Lock 接口比 synchronized 块的优势是什么
    ReadWriteLock是什么？
    锁机制有什么用
    什么是乐观锁（Optimistic Locking）？如何实现乐观锁？如何避免ABA问题
    解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁
    什么时候应该使用可重入锁
    简述锁的等级方法锁、对象锁、类锁
    Java中活锁和死锁有什么区别？
    什么是死锁(Deadlock)？导致线程死锁的原因？如何确保 N 个线程可以访问 N 个资源同时又不导致死锁
    死锁与活锁的区别，死锁与饥饿的区别
    如何实现分布式锁
    有哪些无锁数据结构，他们实现的原理是什么
    读写锁可以用于什么应用场景
    Executors类是什么？ Executor和Executors的区别
    什么是Java线程转储(Thread Dump)，如何得到它
    如何在Java中获取线程堆栈
    说出 3 条在 Java 中使用线程的最佳实践
    在线程中你怎么处理不可捕捉异常
    实际项目中使用多线程举例。你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的
    请说出与线程同步以及线程调度相关的方法
    程序中有3个 socket，需要多少个线程来处理
    假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有 10 个线程同时调用它，如何做到
    如何在 Windows 和 Linux 上查找哪个线程使用的 CPU 时间最长
    如何确保 main() 方法所在的线程是 Java 程序最后结束的线程
    非常多个线程（可能是不同机器），相互之间需要等待协调才能完成某种工作，问怎么设计这种协调方案
    你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它

    2）防止阻塞
    从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。

    3）便于建模
    这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。

4、Runnable接口和Callable接口的区别
    有点深的问题了，也看出一个Java程序员学习知识的广度。
    Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；
    Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。
    这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？
    某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。
    而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。

5、CyclicBarrier和CountDownLatch的区别
    两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：
    1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行。
    2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务。
    3) CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了。


7、什么是线程安全
    如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。
    这个问题有值得一提的地方，就是线程安全也是有几个级别的：
    1）不可变
    像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用

    2）绝对线程安全
    不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet

    3）相对线程安全
    相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。

    4）线程非安全
    这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类，点击这里了解为什么不安全。

 

8、Java中如何获取到线程dump文件
    死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：
    1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java
    2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid
    另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈。

10、如何在两个线程之间共享数据
    通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的。

11、sleep方法和wait方法有什么区别 
    sleep方法和wait方法都可以用来放弃CPU一定的时间，
    不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器
    wait()是object的方法，必须在synchtonied中使用。
    sleep()是Thread类的方法。

12、生产者消费者模型的作用是什么
    这个问题很理论，但是很重要：
    1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用
    2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约

13、ThreadLocal有什么用
    简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了

14、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用
    这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁

15、wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别
    wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。

16、为什么要使用线程池
    避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。


18、synchronized和ReentrantLock的区别
    synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：
    （1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁
    （2）ReentrantLock可以获取各种锁的信息
    （3）ReentrantLock可以灵活地实现多路通知
    另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。

19、ConcurrentHashMap的并发度是什么
    ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，
    任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？

20、ReadWriteLock是什么
    首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。
    因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。

21、FutureTask是什么
    这个其实前面有提到过，FutureTask表示一个异步运算的任务。
    FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。
    当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。

22、Linux环境下如何查找哪个线程使用CPU最长
    这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做：
    （1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过
    （2）top -H -p pid，顺序不能改变
    这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号。
    使用"top -H -p pid"+"jps pid"可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。
    最后提一点，"top -H -p pid"打出来的LWP是十进制的，"jps pid"打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。

23、Java编程写一个会导致死锁的程序
    第一次看到这个题目，觉得这是一个非常好的问题。很多人都知道死锁是怎么一回事儿：线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。
    当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。

    真正理解什么是死锁，这个问题其实不难，几个步骤：
    1）两个线程里面分别持有两个Object对象：lock1和lock2。这两个lock作为同步代码块的锁；
    2）线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，50毫秒差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁
    3）线程2的run)(方法中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁，当然这时lock1的对象锁已经被线程1锁持有，线程2肯定是要等待线程1释放lock1的对象锁的
    这样，线程1"睡觉"睡完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。代码就不写了，占的篇幅有点多，Java多线程7：死锁这篇文章里面有，就是上面步骤的代码实现。

24、怎么唤醒一个阻塞的线程
    如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；
    如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。

25、不可变对象对多线程有什么帮助
    前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。

26、什么是多线程的上下文切换
    多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。

27、如果你提交任务时，线程池队列已满，这时会发生什么
    这里区分一下：
    1）如果使用的是无界队列LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务
    2）如果使用的是有界队列比如ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，会根据maximumPoolSize的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy

28、Java中用到的线程调度算法是什么
    抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。

29、Thread.sleep(0)的作用是什么
    由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，
    可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。

30、什么是自旋
    很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。
    既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。
    如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。
    
31、什么是Java内存模型
    Java内存模型定义了一种多线程访问Java内存的规范。Java内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下Java内存模型的几部分内容：
    1）Java内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去
    2）定义了几个原子操作，用于操作主内存和工作内存中的变量
    3）定义了volatile变量的使用规则
    4）happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的

32、什么是CAS
    CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，
    否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，
    只要某次CAS操作失败，永远都不可能成功。

33、什么是乐观锁和悲观锁
    1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。
    2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。

34、什么是AQS
    简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。
    如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。
    AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。
    AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。

 

35、单例模式的线程安全性

老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：

1）饿汉式单例模式的写法：线程安全

2）懒汉式单例模式的写法：非线程安全

3）双检锁单例模式的写法：线程安全

 

36、Semaphore有什么作用

Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。

 

37、Hashtable的size()方法中明明只有一条语句"return count"，为什么还要做同步？

这是我之前的一个困惑，不知道大家有没有想过这个问题。某个方法中如果有多条语句，并且都在操作同一个类变量，那么在多线程环境下不加锁，势必会引发线程安全问题，这很好理解，但是size()方法明明只有一条语句，为什么还要加锁？

关于这个问题，在慢慢地工作、学习中，有了理解，主要原因有两点：

1）同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性

2）CPU执行代码，执行的不是Java代码，这点很关键，一定得记住。Java代码最终是被翻译成机器码执行的，机器码才是真正可以和硬件电路交互的代码。即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个。一句"return count"假设被翻译成了三句汇编语句执行，一句汇编语句和其机器码做对应，完全可能执行完第一句，线程就切换了。

 

38、线程类的构造方法、静态块是被哪个线程调用的

这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。

如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：

1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的

2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的

 

39、同步方法和同步块，哪个是更好的选择

同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。

借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁->解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁-->解锁的次数，有效地提升了代码执行的效率。

 

40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？

这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是：

1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换

2）并发不高、任务执行时间长的业务要区分开看：

a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务

b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换

c）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考其他有关线程池的文章。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。

22、Java中线程安全的机制，如何实现？实现方式？yeild的方法的使用？会释放锁吗？线程死锁？
23、Java中 volatile关键字的含义及其使用方法？
24、java线程池？线程池构造函数的几个参数含义？keepAliveTime解释一下？
25、一个接口，要去调用另外5个接口，每一个接口都会返回数据给这个调用接口，调用接口要对数据进行合并并返回给上层。
    这样一种场景可能用到并发包下的哪些类？你会怎么去实现这样的业务场景？
16、CountDownLatch和CyclicBarrier的区别？
17、线程加锁有哪些方式？synchronized和lock的区别？
18、volatile关键字的作用？为什么使用AtomicLong而不使用Long?AtomicLong的底层是怎么实现的？

20、synchronized和lock有什么区别？
21、synchronized 和 ReentranLock的区别？
22、ThreadLocal？应用场景？
23、不管你是新程序员还是老手，你一定在面试中遇到过有关线程的问题。
Java语言一个重要的特点就是内置了对并发的支持，让Java大受企业和程序员的欢迎。
大多数待遇丰厚的Java开发职位都要求开发者精通多线程技术并且有丰富的Java程序开发、调试、优化经验，
所以线程相关的问题在面试中经常会被提到。

在典型的Java面试中， 面试官会从线程的基本概念问起, 
如：为什么你需要使用线程， 如何创建线程，用什么方式创建线程比较好（比如：继承thread类还是调用Runnable接口），
然后逐渐问到并发问题像在Java并发编程的过程中遇到了什么挑战，Java内存模型，JDK1.5引入了哪些更高阶的并发工具，
并发编程常用的设计模式，经典多线程问题如生产者消费者，哲学家就餐，读写器或者简单的有界缓冲区问题。
仅仅知道线程的基本概念是远远不够的， 你必须知道如何处理死锁，竞态条件，内存冲突和线程安全等并发问题。
掌握了这些技巧，你就可以轻松应对多线程和并发面试了。

许多Java程序员在面试前才会去看面试题，这很正常。
因为收集面试题和练习很花时间，所以我从许多面试者那里收集了Java多线程和并发相关的50个热门问题。
我只收集了比较新的面试题且没有提供全部答案。
想必聪明的你对这些问题早就心中有数了， 如果遇到不懂的问题，你可以用Google找到答案。
若你实在找不到答案，可以在文章的评论中向我求助。你也可以在这找到一些答案Java线程问答Top 12。

50道Java线程面试题
下面是Java线程相关的热门面试题，你可以用它来好好准备面试。

1) 什么是线程？
线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。欲了解更多详细信息请点击这里。

2) 线程和进程有什么区别？
线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。
不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。
别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。

3) 如何在Java中实现线程？
    在语言层面有两种方式。
    1、继承Thread类
    2、实现Runnable接口
    3、实现Callable接口
    4、线程池

4) 用Runnable还是Thread？
这个问题是上题的后续，大家都知道我们可以通过继承Thread类或者调用Runnable接口来实现线程，问题是，那个方法更好呢？
什么情况下使用它？这个问题很容易回答，如果你知道Java不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他类，当然是调用Runnable接口好了。

6) Thread 类中的start() 和 run() 方法有什么区别？
这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。
start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。
当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。更多讨论请点击这里

7) Java中Runnable和Callable有什么不同？
Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这些功能。Callable可以返回装载有计算结果的Future对象。我的博客有更详细的说明。

8) Java中CyclicBarrier 和 CountDownLatch有什么不同？
CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。与 CyclicBarrier 不同的是，CountdownLatch 不能重新使用。点此查看更多信息和示例代码。

9) Java内存模型是什么？
Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。比如，先行发生关系确保了：

线程内的代码能够按先后顺序执行，这被称为程序次序规则。
对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。
前一个对volatile的写操作在后一个volatile的读操作之前，也叫volatile变量规则。
一个线程内的任何操作必需在这个线程的start()调用之后，也叫作线程启动规则。
一个线程的所有操作都会在线程终止之前，线程终止规则。
一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。
可传递性
我强烈建议大家阅读《Java并发编程实践》第十六章来加深对Java内存模型的理解。

10) Java中的volatile 变量是什么？
volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生，就是上一题的volatile变量规则。点击这里查看更多volatile的相关内容。

11) 什么是线程安全？Vector是一个线程安全类吗？ （详见这里)
如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。

12) Java中什么是竞态条件？ 举个例子说明。
竞态条件会导致程序在并发情况下出现一些bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的bugs。这种bugs很难发现而且会重复出现，因为线程间的随机竞争。一个例子就是无序处理，详见答案。

13) Java中如何停止一个线程？
    Java提供了很丰富的API但没有为停止线程提供API。
    JDK 1.0本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了，之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。
    当run() 或者 call() 方法执行完的时候线程会自动结束,如果要手动结束一个线程，你可以用volatile 布尔变量来退出run()方法的循环或者是取消任务来中断线程。

    中断线程：
        1）stop()方法
            已经被遗弃，调用stop后，线程会立即停止，导致线程逻辑有一部分未执行，造成不可预期的结果。
        2）interrup()方法
            public class InterruptThread implements Runnable{
                @Override
                public void run() {
                    while(!Thread.currentThread().isInterrupted()){
                        System.out.println("线程:" + Thread.currentThread().getName() + "正在运行");
                    }
                }
                public static void main(String[] args) throws InterruptedException {
                    Thread t = new Thread(new InterruptThread(), "可打断的线程");
                    t.start();
                    Thread.sleep(2000L);
                    t.interrupt();
                }
            }
        3）使用volatitle模拟interrupt
            public class DIYStopThread implements Runnable{
                private static volatile boolean FLAG = true;
                private static int num = 0;
                @Override
                public void run() {
                    while(FLAG){
                        num++;
                        System.out.println("线程:" + Thread.currentThread().getName() + "正在运行");
                    }
                }
                public static void main(String[] args) throws InterruptedException {
                    Thread  t = new Thread(new DIYStopThread());
                    t.start();
                    Thread.sleep(2000L);
                    FLAG = false;
                    System.out.println(num);
                }
            }


14) 一个线程运行时发生异常会怎样？
    如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放

    Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。
    当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。

16) Java中notify 和 notifyAll有什么区别？
    这又是一个刁钻的问题，因为多线程可以等待单监控锁，
    Java API 的设计人员提供了一些方法当等待条件改变的时候通知它们，但是这些方法没有完全实现。
    notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。
    而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。

17) 为什么wait, notify 和 notifyAll这些方法不在thread类里面？
    这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。
    回答这些问题的时候，你要说明为什么把这些方法放在Object类里是有意义的，还有不把它放在Thread类里的原因。
    一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。
    如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。
    简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。

18) 什么是ThreadLocal变量？
    ThreadLocal是Java里一种特殊的变量。
    每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。
    它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，
    如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。
    其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。
    线程局部变量的另一个不错的例子是ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数。

19) 什么是FutureTask？
    在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。
    只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。
    一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。

20) Java中interrupted 和 isInterruptedd方法的区别？
    interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。

21) 为什么wait和notify方法要在同步块中调用？
    主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。
    还有一个原因是为了避免wait和notify之间产生竞态条件。

22) 为什么你应该在循环中检查等待条件?
    处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。
    因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。
    这就是在循环中使用wait()方法效果更好的原因，你可以在Eclipse中创建模板调用wait和notify试一试。

    synchronized (obj) {
        while (<condition does not hold>)
            obj.wait();
        ... // Perform action appropriate to condition
    }
    线程醒来的时候，可能条件被其他线程修改了，那就要重复判断条件。

23) Java中的同步集合与并发集合有什么区别？
    同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。更多内容详见答案。

24） Java中堆和栈有什么不同？
    为什么把这个问题归类在多线程和并发面试题里？因为栈是一块和线程紧密相关的内存区域。每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。

25） 什么是线程池？ 为什么要使用它？
    创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。更多内容详见这篇文章。

26） 如何写代码来解决生产者消费者问题？
    在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务供其它线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比较低级的办法是用wait和notify来解决这个问题，比较赞的办法是用Semaphore 或者 BlockingQueue来实现生产者消费者模型，这篇教程有实现它。

27） 如何避免死锁？
    Java多线程中的死锁
    死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：

    互斥条件：一个资源每次只能被一个进程使用。
    请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
    不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
    循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。
    避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。这篇教程有代码示例和避免死锁的讨论细节。

28) Java中活锁和死锁有什么区别？
    这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。
    一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。
    简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。

29） 怎么检测一个线程是否拥有锁？
    我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我参加了一次电话面试。
    在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。

30) 你如何在Java中获取线程堆栈？
    对于不同的操作系统，有多种方法来获得Java进程的线程堆栈。当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台。在Windows你可以使用Ctrl + Break组合键来获取线程堆栈，Linux下用kill -3命令。你也可以用jstack这个工具来获取，它对线程id进行操作，你可以用jps这个工具找到id。

31) JVM中哪个参数是用来控制线程的栈堆栈小的
    这个问题很简单， -Xss参数用来控制线程的堆栈大小。你可以查看JVM配置列表来了解这个参数的更多信息。

32） Java中synchronized 和 ReentrantLock 有什么不同？
    Java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法或者块边界，尝试获取锁时不能中途取消等。Java 5 通过Lock接口提供了更复杂的控制来解决这些问题。 ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义且它还具有可扩展性。你可以查看这篇文章了解更多

33） 有三个线程T1，T2，T3，怎么确保它们按顺序执行？
    在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。你可以查看这篇文章了解更多。

34) Thread类中的yield方法有什么作用？
    Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。
    它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。

35） Java中ConcurrentHashMap的并发度是什么？
    ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。
    这种划分是使用并发度获得的，它是ConcurrentHashMap类构造函数的一个可选参数，默认值为16，这样在多线程情况下就能避免争用。

36） Java中Semaphore是什么？
    Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。更多详细信息请点击这里。

37）如果你提交任务时，线程池队列已满。会时发会生什么？
这个问题问得很狡猾，许多程序员会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么ThreadPoolExecutor’s submit()方法将会抛出一个RejectedExecutionException异常。

38) Java线程池中submit() 和 execute()方法有什么区别？
两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。更多详细信息请点击这里。

39) 什么是阻塞式方法？
阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。更多详细信息请点击这里。

40) Swing是线程安全的吗？ 为什么？
你可以很肯定的给出回答，Swing不是线程安全的，但是你应该解释这么回答的原因即便面试官没有问你为什么。当我们说swing不是线程安全的常常提到它的组件，这些组件不能在多线程中进行修改，所有对GUI组件的更新都要在AWT线程中完成，而Swing提供了同步和异步两种回调方法来进行更新。点击这里查看更多swing和线程安全的相关内容。

41） Java中invokeAndWait 和 invokeLater有什么区别？
这两个方法是Swing API 提供给Java开发者用来从当前线程而不是事件派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用invokeAndWait()方法请求事件派发线程对组件进行相应更新。而invokeLater()方法是异步调用更新组件的。更多详细信息请点击这里。

42) Swing API中那些方法是线程安全的？
这个问题又提到了swing和线程安全，虽然组件不是线程安全的但是有一些方法是可以被多线程安全调用的，比如repaint(), revalidate()。 JTextComponent的setText()方法和JTextArea的insert() 和 append() 方法也是线程安全的。

43) 如何在Java中创建Immutable对象？
这个问题看起来和多线程没什么关系， 但不变性有助于简化已经很复杂的并发程序。Immutable对象可以在没有同步的情况下共享，降低了对该对象进行并发访问时的同步化开销。可是Java没有@Immutable这个注解符，要创建不可变类，要实现下面几个步骤：通过构造方法初始化所有成员、对变量不要提供setter方法、将所有的成员声明为私有的，这样就不允许直接访问这些成员、在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝。我的文章how to make an object Immutable in Java有详细的教程，看完你可以充满自信。

44） Java中的ReadWriteLock是什么？
一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。Java中的ReadWriteLock是Java 5 中新增的一个接口，一个ReadWriteLock维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下一个读锁可能会同时被多个读线程持有。写锁是独占的，你可以使用JDK中的ReentrantReadWriteLock来实现这个规则，它最多支持65535个写锁和65535个读锁。

45) 多线程中的忙循环是什么?
忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。你可以查看这篇文章获得更多信息。

46）volatile 变量和 atomic 变量有什么不同？
这是个有趣的问题。首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。

47) 如果同步块内的线程抛出异常会发生什么？
这个问题坑了很多Java程序员，若你能想到锁是否释放这条线索来回答还有点希望答对。无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在finally block里释放锁实现。

48） 单例模式的双检锁是什么？
这个问题在Java面试中经常被问到，但是面试官对回答此问题的满意度仅为50%。一半的人写不出双检锁还有一半的人说不出它的隐患和Java1.5是如何对它修正的。它其实是一个用来创建线程安全的单例的老方法，当单例实例第一次被创建时它试图用单个锁进行性能优化，但是由于太过于复杂在JDK1.4中它是失败的，我个人也不喜欢它。无论如何，即便你也不喜欢它但是还是要了解一下，因为它经常被问到。你可以查看how double checked locking on Singleton works这篇文章获得更多信息。

49） 如何在Java中创建线程安全的Singleton？
这是上面那个问题的后续，如果你不喜欢双检锁而面试官问了创建Singleton类的替代方法，你可以利用JVM的类加载和静态变量初始化特征来创建Singleton实例，或者是利用枚举类型来创建Singleton，我很喜欢用这种方法。你可以查看这篇文章获得更多信息。

50) 写出3条你遵循的多线程最佳实践
这种问题我最喜欢了，我相信你在写并发代码来提升性能的时候也会遵循某些最佳实践。以下三条最佳实践我觉得大多数Java程序员都应该遵循：

给你的线程起个有意义的名字。
这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。
避免锁定和缩小同步的范围
锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。
多用同步类少用wait 和 notify
首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。
多用并发集合少用同步集合
这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。我的文章Java并发集合有更详细的说明。
51) 如何强制启动一个线程？
这个问题就像是如何强制进行Java垃圾回收，目前还没有觉得方法，虽然你可以使用System.gc()来进行垃圾回收，但是不保证能成功。在Java里面没有办法强制启动一个线程，它是被线程调度器控制着且Java没有公布相关的API。

52) Java中的fork join框架是什么？
fork join框架是JDK7中出现的一款高效的工具，Java开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。你可以查看这篇文章获得更多信息。

53） Java多线程中调用wait() 和 sleep()方法有什么不同？
Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。你可以查看这篇文章获得更多信息。

以上就是50道热门Java多线程和并发面试题啦。我没有分享所有题的答案但给未来的阅读者提供了足够的提示和线索来寻找答案。如果你真的找不到某题的答案，联系我吧，我会加上去的。这篇文章不仅可以用来准备面试，还能检查你对多线程、并发、设计模式和竞态条件、死锁和线程安全等线程问题的理解。我打算把这篇文章的问题弄成所有Java多线程问题的大合集，但是没有你的帮助恐怖是不能完成的，你也可以跟我分享其它任何问题，包括那些你被问到却还没有找到答案的问题。这篇文章对初学者或者是经验丰富的Java开发人员都很有用，过两三年甚至五六年你再读它也会受益匪浅。它可以扩展初学者尤其有用因为这个可以扩展他们的知识面，我会不断更新这些题，大家可以在文章后面的评论中提问，分享和回答问题一起把这篇面试题完善。

22、为什么要使用线程池？
    线程创建消耗cpu和时间，如果任务来了再创建线程会时间开销。

3、线程池有什么作用？
    1）减少了创建和销毁线程的次数，线程创建过程消耗cpu和时间，每个线程都可以被重复利用。
    2）任务来了就能执行
    3）方便控制线程数量和复用线程

3.1 多线程一定比单线程高效吗？
    不一定，多线程会有上下文切换开销，单线程没有这种开销。多线程会有锁的问题。

4、说说几种常见的线程池及使用场景。
    1）newSingleThreadExecutor 创建一个单线程化的线程池，只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。
    2）newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
    3）newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超多处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
    4）newScheduledThreadPool 创建一个定长线程池，支持定时周期性任务执行。
    批量发邮件、短信、订阅
5、线程池都有哪几种工作队列？
    1）ArrayBlockingQueue 基于数组结构的有界阻塞队列，此队列按先进先出原则对元素进行排序。
    2）LinkedBlockingQueue 基于链表结构的阻塞队列，此队列按先进先出排序元素。
    3）SynchronousQueue 不存储元素的阻塞队列。每个插入操作必须等待到另一个线程调用移除操作，否则插入操作一直处于阻塞状态。
    4）PriorityBlockingQueue 具有优先级的无限阻塞队列。
    https://www.jianshu.com/p/6c6f396fc88e
5、线程池大小设置
    https://www.cnblogs.com/cjsblog/p/9068886.html
    任务类型：CPU密集型、IO密集型、混合型。
    1）cpu密集型任务
        尽量使用较小的线程池，一般为N+1。即使当计算密集型的线程偶尔由于缺失故障或者其他原因而暂停时，这个额外的线程也能确保CPU的时钟周期不会被浪费。
        CPU密集型任务使得CPU使用率很高，若开过多的线程，只能增加上下文切换的次数，因此会带来额外的开销。
    2）可以使用稍大的线程池，一般为2*N+1。
        IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候去处理别的任务，充分利用CPU时间。
    3）
7、线程池中的几种重要的参数及流程说明。
    https://reeboo.iteye.com/blog/1936424
    https://www.cnblogs.com/aspirant/p/8628843.html
    handler：表示当拒绝处理任务时的策略。
    threadFactory：线程工厂，用来创建线程。
    corePoolSize：线程池中允许同时运行的最大线程数。
    maxinumPoolSize：线程池允许的最大线程数，表示最大能创建多少个线程，大于等于corePoolSize
    keepAliveTime：线程没有任务时最多保持多久然后停下。

Java线程的状态有哪些，它们是何时、如何（通过什么方法）进行转换的

什么是CopyOnWriteArrayList，如何使用它？
    读写分离，写时复制出一个新的数组，完成插入、修改或者移除操作后将新数组赋值给array

如何创建或保证一个Map、List的线程安全？
    HashMap不是线程安全的。
    HashTable线程安全，加了synchronized关键字。
    ArrayList线程不安全。
    Collections.synchronizedList与CopyOnWriteArrayList是线程安全的。

多线程同步锁
    A，RentrantLock，可重入的互斥锁，可中断可限时，公平锁，必须在finally释放锁，而synchronize由JVM释放。可重入但是要重复退出，普通的lock()不能响应中断，lock.lockInterruptbly()可响应中断，可以限时tryLock()，超时返回false，不会永久等待构成死锁。
    B，Confition条件变量，signal唤醒其中1个在等待的线程，signalall唤醒所有在等待的线程await()等待并释放锁，与lock结合使用。
    C，semaphore信号量，多个线程比（额度=10）进入临界区，其他则阻塞在临界区外。
    D，ReadWriteLock，读读不互斥，读写互斥，写写互斥。
    E，CountDownLantch倒数计时器，countdown()和await()
    F，CyCliBarrier
    G，LockSupport，方法park和unpark

Java 锁中，synchronized RentrantLock 分别在什么场景下使用，如何使用？
    synchronized缺点：
        不能中断，没有超时机制。
    ReentrantLock优点：
        可一直等待获取锁；lock()
        可尝试一次获取锁；tryLock()
        可获取锁超时；tryLock(timeout)
        可中断获取锁；lockInterruptibly()和intrrupt()结合
RentrantLock 提供主要哪些方法？
    一个可重用的互斥锁，有synchronized的功能，但更强大。
    * ReentrantLock(boolean fair)
         创建公平/非公平策略的ReentrantLock。
    * lock() 
        获取锁。如果锁已被其他线程获取，则进行等待。
    * tryLock()
        尝试一次获取锁
    * tryLock(long timeout, TimeUnit unit)
        尝试获取锁的时间为timeout
    * unlock()
        释放锁
    * newCondition()
        Lock lock = new ReentrantLock();
        Condition condition = lock.newCondition();
        condition.await();
        condition.singal();  
    * lockInterruptibly()
        使用lockInterruptibly()获取锁的时，如果未获取到锁可以使用interrupt()中断。

如何唤醒一个阻塞的线程？
    1）suspend和resume
        suspend暂停线程的同时，并不会去释放任何锁资源，其他线程访问不到它占用的锁，直到对应的线程执行resume()方法后，
        被挂起的线程才能继续，从而其他被阻塞在这个锁的线程才可以继续执行。
        但是，如果resume()操作在suspend()之前执行，那么线程将一直处于挂起状态，同时一直占用锁，这就产生了死锁。
    2）wait和notify
        wait与notify必须配合synchronized使用，因为调用之前必须持有锁，wait会立即释放锁，notify则是同步块执行完了才释放
    3）awit和singal
        Condition类提供，而Condition对象由new ReentLock().newCondition()获得，与wait和notify相同，因为使用Lock锁后无法使用wait方法
        Lock实现主要是基于AQS，而AQS实现则是基于LockSupport，所以说LockSupport更底层，所以使用park效率会高一些
    4）park和unpark
        ```
        public class SuspendResumeTest {
            public static Object object = new Object();
            static TestThread t1 = new TestThread("线程1");
            static TestThread t2 = new TestThread("线程2");
            public static class TestThread extends Thread{
                public TestThread(String name) {
                    super.setName(name);
                }
                @Override
                public void run() {
                    synchronized (object) {
                        System.out.println(getName()+" 占用。。");
                        Thread.currentThread().suspend();
        //                LockSupport.park();
                    }
                }
            }
            public static void main(String[] args) throws InterruptedException {
                t1.start();
                Thread.sleep(200);
                t2.start();
                t1.resume();
        //        LockSupport.unpark(t1);
        //        LockSupport.unpark(t2);
                t2.resume();
                t1.join();
                t2.join();
            }
        ```

什么是死锁、活锁，无锁？
    死锁：多个线程互相等待对方释放资源。
    饥饿锁：多线程中优先级高的会优先执行，并且抢占优先级低的资源，导致优先级低的线程无法得到执行。
    无锁：没有锁，多个线程都争抢这修改资源。CAS。
    活锁：多线程中出现了相互谦让，都制动将资源释放给别的线程使用，这样资源在多个线程之间跳动而又得不到使用，形成活锁。

多线程锁的升级原理是什么？


35.并行和并发有什么区别？
    单个CPU执行多个线程，多个线程按时间片轮流执行就是并发。每一时刻，只会有一个线程被执行。
    多个CPU同时执行多个线程是并行，同一时刻可以有多个线程在执行。
36.线程和进程的区别？
    进程是资源（cpu、内存等）分配的最小单位，线程是程序执行的最小单位。
    一个进程可以有多个线程。
    进程粒度比线程大。

37.守护线程是什么？
    只有当最后一个非守护线程结束时，守护线程才会随着JVM一同结束。
    GC是守护线程。
    childThread.setDaemon(true);必须在childThread.start();之前。
    在Daemon线程中产生的新线程也是Daemon的。
    java的线程池会将守护线程转换为用户线程。

    public class DeamonTest {
        public static void main(String[] args) {
            Thread mainThread = new Thread(new Runnable() {
                @Override
                public void run() {
                    Thread childThread = new Thread(new ChildThread());
                    // 将childThread设置为守护线程。
                    // mainThread线程退出后，守护线程也即退出
                    childThread.setDaemon(true);
                    childThread.start();
                    System.out.println("DeamonTest.run");
                }
            });
            mainThread.start();
        }
    }   
38.创建线程有哪几种方式？
    1) 继承Thread
    2) 实现Runnable
    3) Callable和FutureTask
        1)和2)的缺陷是：在执行完任务之后无法获取执行结果。
        
        FutureTask是一种可以取消的异步的计算任务。它的计算是通过Callable实现的，等价于可以携带结果的Runnable。
        有三个状态：等待、运行、完成（完成包括所有计算以任意的方式结束(正常结束、取消、异常)）。
        主要方法：
            1、get() 获取结果只有在计算完成时获取，否则一直阻塞直到任务转入完成状态。
    https://www.cnblogs.com/dolphin0520/p/3949310.html
    http://www.importnew.com/30531.html
        
        FutureTask实现了Runnable和Future

        public class MyCallable implements Callable<String> {
            private int count = 20;

            @Override
            public String call() throws Exception {
                for (int i = count; i >0 ; i--) {
                    System.out.println(Thread.currentThread().getName()+"当前票数：" + i);
                }
                return "sale out";
            }

            public static void main(String[] args) throws ExecutionException, InterruptedException {
                Callable<String> callable = new MyCallable();
                FutureTask<String> futureTask = new FutureTask<>(callable);
                Thread mThread = new Thread(futureTask);
                Thread mThread2 = new Thread(futureTask);
                Thread mThread3 = new Thread(futureTask);
                mThread.start();
                mThread2.start();
                mThread3.start();
                System.out.println(futureTask.get());
            }
        }

39.说一下 runnable 和 callable 有什么区别？
    1、Runnable线程体在run()中，callable线程体在call()中。
    2、Callable接口支持返回线程执行结果，通过FutureTask.get()方法获取执行结果，get方法会阻塞直到结果返回。
    3、Runnable没有返回值。Callable + FutureTask 可以获取多线程运行的结果，也可以在等待太长时间没有获取到需要的数据的情况下取消该线程的任务。

40.线程有哪些状态？
    1、新建（NEW）：实现Runnable接口和继承Thread可以得到一个线程类，new一个实例，线程就进入了新建状态，即 start() 之前的状态。
    2、可运行（RUNNABLE）：
            有资格运行，但还没运行，等待调度。
            调用线程的start()方法。
            当前线程的sleep()结束。
            其他线程join()结束。
            调用当前线程的yield()方法。
    3、运行（RUNNING）
            线程调度程序从可运行池中选择一个线程设置为当前线程，这是线程进入运行状态的唯一方式。
    4、阻塞（BLOCKED）
            当前线程调用Thread.sleep()。
            运行在当前线程的其他线程调用join()方法。
            等待用户输入的时候。
    5、死亡（DEAD）
            线程的run()方法完成时，就死去了，死去的线程不能复生。
            或程序退出。


42.notify()和 notifyAll()有什么区别？
    notify()唤醒在此监视器上等待的一个线程。
    notifyAll()唤醒在此监视器上等待的全部线程。
    但都要等到当前线程释放锁之后，被唤醒的线程才有可能执行。

43.线程的 run()和 start()有什么区别？
    调用Thread的start()方法，可以异步启动线程，但启动的线程不会马上运行，会放到等待队列中等待CPU调度。只有线程被CPU调度才会调用run()方法执行。
    线程的逻辑写在run()。线程创建后只有调用start()之后才能进入可运行状态，等待调度执行。
    可直接调用run()方法。

44.创建线程池有哪几种方式？
    newSingleThreadExecutor
    创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。
    
    newFixedThreadPool
    创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。
    
    newCachedThreadPool
    创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，
    那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。
    
    newScheduledThreadPool
    创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。

45.线程池都有哪些状态？

46.线程池中 submit()和 execute()方法有什么区别？
    创建并开启一个线程开销很大，线程池可以避免频繁创建关闭线程，以缓解性能问题。
    线程在被使用前就存在线程池，执行完任务后，线程返回线程池等待下次使用。
    java通过executor对象来实现自己的线程池模型，可以使用exector接口或其他线程池的实现。

    execute(Runnable x) 没有返回值。可以执行任务，但无法判断任务是否成功完成。——实现Runnable接口
    submit(Runnable x) 返回一个future。可以用这个future来判断任务是否成功完成。——实现Callable接口

    =============接口Executor==========================
    ```
    简单使用:
    public class mainTest {
        public static void main(String[] args) {
            Executor executor = Executors.newSingleThreadExecutor();
            executor.execute(new Runnable() {
                @Override
                public void run() {
                    System.out.println("mainTest.run");
                }
            });
        }
    }
    ```
    如果有工作线程可用，execute()方法将执行语句，否则就把Runnable任务放进队列，等待线程可用。
    
    Executors类里的工厂方法可以创建很多类型的线程池（最终构建线程池使用ThreadPoolExecutor）：
    newSingleThreadExecutor()：包含单个线程和无界队列的线程池，同一时间只能执行一个任务。
    newFixedThreadPoll()：包含固定数量线程并共享无界队列的线程池；当所有线程处于工作状态，有新任务提交时，任务在队列中等待，直到一个线程变为可用状态。
    newCacheThreadPool()：只有需要时创建新线程的线程池。
    newWorkStealingThreadPool()：基于工作窃取算法的线程池。

    ====================接口ExecutorService===============
    ExecutorService是Executor的子接口，其定义了更多的方法。
    submit()方法可以返回Furute对象。
    
    ===================接口ScheduledExecutorService========
    ScheduledExecutorService是ExecutorService的一个子接口，增加了调度任务的方法。
    sechedule()方法的参数指定执行的方法、延时和TimeUnit
    
    ```
    ScheduledExecutorService executor = Executors.newScheduledThreadPool(10);
    Future<Double> future = executor.schedule(callableTask, 2, TimeUnit.MILLISECONDS); 
    ```
    =================ThreadPoolExecutor和ForkJoinPool==============
    ExecutorService的两个实现。
