5、jvm中一次完整的GC流程（从ygc到fgc）是怎样的，重点讲讲对象如何晋升到老年代，几种主要的jvm参数等

6、你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms，g1

7、新生代和老生代的内存回收策略

10、JVM的编译优化


12、指令重排序，内存栅栏等

13、OOM错误，stackoverflow错误，permgen space错误

14、JVM常用参数
    GC是什么？为什么要有GC
        GC：垃圾收集。
        内存有限，有些对象不再使用后就成了垃圾，回收垃圾避免内存泄露。

    GC是怎么样运行的
        创建对象后，jvm就开始监控这个对象，标记“不可达”的对象，在下次GC时回收这些垃圾。

    GC 有几种方式？怎么配置

    什么时候一个对象会被GC？ 如何判断一个对象是否存活
        引用计数：
            有引用，计数器+1；无引用，计数器-1。计数器为0的对象不可使用。
            jvm没有采用此方法，因为很难解决循环引用的问题。
        可达性分析算法：
            通过一系列被称为“GC Roots”的对象为起始点，从这些节点开始搜索，无法到达的对象是不可用的。
            不可达对象在被回收之前，如果覆盖了finalize()方法，并且方法中将自身this赋值给其他对象，则该对象不会被GC。
            可作为GC Roots的对象：
                虚拟机栈（栈帧中的本地变量表）中引用的对象。
                方法区中类静态属性引用的对象。
                方法区中常量引用的对象。
                本地方法栈中JNI（即一般说的Native方法）引用的对象。
    System.gc() Runtime.gc()会做什么事情？ 能保证 GC 执行吗
        会建议jvm在适当的时候GC，只是建议。

    垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？
        有可能会马上回收，System.gc()调用后，会建议jvm在适当的时候GC，仅仅是建议。
        可通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。

    Minor GC 、Major GC、Young GC 与 Full GC分别在什么时候发生
    
    垃圾回收算法的实现原理
    
    如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？
        不会立即释放，
    
    GC收集器有哪些

    垃圾回收器的基本原理是什么？

    串行(serial)收集器和吞吐量(throughput)收集器的区别是什么
    
    Serial 与 Parallel GC之间的不同之处
    
    CMS 收集器 与 G1 收集器的特点与区别
    
    CMS垃圾回收器的工作过程
    
    吞吐量优先和响应优先的垃圾收集器选择

    举个实际的场景，选择一个GC策略

    JVM的永久代中会发生垃圾回收吗
        会。三个条件：
        1、该类的实例都被回收
        2、加载该类的classLoader已经被回收
        3、该类不能通过反射访问到其方法，而且该类的java.lang.class没有被引用。

    收集方法
    
    标记清除、标记整理、复制算法的原理与特点？分别用在什么地方
    
    如果让你优化收集方法，有什么思路

16、JVM
    参数
    xmx xms xmn 这三个参数代表我对于虚拟机做了什么限制吗？ （控制内存大小）
    说说你知道的几种主要的jvm 参数
    -XX:+UseCompressedOops 有什么作用
    类加载器(ClassLoader)

    Java 类加载器都有哪些
    JVM如何加载字节码文件
    内存管理

    JVM内存分哪几个区，每个区的作用是什么
    一个对象从创建到销毁都是怎么在这些部分里存活和转移的
    解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法
    JVM中哪个参数是用来控制线程的栈堆栈小
    简述内存分配与回收策略
    简述重排序，内存屏障，happen-before，主内存，工作内存
    Java中存在内存泄漏问题吗？请举例说明
    简述 Java 中软引用（SoftReferenc）、弱引用（WeakReference）和虚引用
    内存映射缓存区是什么
    jstack，jstat，jmap，jconsole怎么用
    32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？32 位和 64 位的 JVM，int 类型变量的长度是多数？
    怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位
    JVM自身会维护缓存吗？是不是在堆中进行对象分配，操作系统的堆还是JVM自己管理堆
    什么情况下会发生栈内存溢出
18、jvm中哪些对象是需要被回收的
23、内存溢出一般发生在哪个区？永久代会不会导致内存溢出？
24、栈会不会溢出？栈溢出一般抛什么异常？jvm在哪里设置栈的大小？设置的参数是什么？
25、用过哪些命令查看jvm的状态、堆栈信息？
28、nio中， 如果不显式的调用system.gc()那会出现什么问题？
    jvm的垃圾回收分为哪些种类？每一种都是怎么去实现的？讲述一下G1的回收策略？
    jvm中的参数分为哪些种类，都是做什么的？jvm的监控怎么做？实际项目上线以后的监控怎么做？
    JVM中，如果把堆内存参数配置的超过了本地内存，会怎么样？
    JVM中的内存结构分为哪些方面？
    栈空间是怎么样的？每个线程只有一个栈吗？
    栈空间的内部结构是怎么样的？

30、如何理解内存泄漏问题？有哪些情况会导致内存泄露？如何解决？
    内存泄漏：当对象已经不再被使用，但是java的垃圾回收器不能回收它们，就产生了内存泄漏。
    1）大对象使用后未赋值为null。
    2）使用集合时，在使用完成后赋值为nul。
    3）避免死循环等重复创建或对集合添加元素，撑爆内存。
    4）静态成员持有对象。
    5）及时的关闭打开文件，socket句柄等。
    Java服务器表现怪异的主要根源是：垃圾回收GC。
    https://yq.aliyun.com/articles/666058
31、如何进行JVM调优？有哪些方法？

46、如何解决内存碎片的问题？

47、如何解决同时存在的对象创建和对象回收问题？

48、讲一讲内存分代及生命周期。

49、什么情况下触发垃圾回收？

50、如何选择合适的垃圾收集算法？

51、JVM中最大堆大小有没有限制？

52、堆大小通过什么参数设置？

53、JVM有哪三种垃圾回收器？

54、吞吐量优先选择什么垃圾回收器？响应时间优先呢？
55、Java中，栈的大小通过什么参数来设置？
35、Java虚拟机中，数据类型可以分为哪几类？
    基本类型和引用类型。
    基本类型的变量保存原始值；引用类型的变量保存引用值。
    https://www.cnblogs.com/cxzdy/p/5388509.html
36、怎么理解栈、堆？堆中存什么？栈中存什么？

37、为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？
    堆栈分离，使得堆中的内容可以被多个栈共享，即多线程访问同一个对象。
    模块化，堆中数据和栈中数据有不同点。
    https://www.jianshu.com/p/05b4830a0010
38、在Java中，什么是是栈的起始点，同是也是程序的起始点？
    main()方法。
    虚拟机栈存放的是栈帧，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。
39、为什么不把基本类型放堆中呢？
    基本类型占用的空间一般是1~8字节，需要空间比较少，而且因为是基本类型，所以不会出现动态增长（长度固定），因此栈中存储就够了。
    基本类型和对象的引用都是存放在栈中，而且都是几个字节，因此程序运行时，他们的处理方式是统一的。
    https://soswm.iteye.com/blog/2272179
20、什么是虚拟主机及实现原理？

21、什么是Java虚拟机，为什么要使用？

什么情况下会发生栈内存溢出。
    方法执行时创建的帧栈超过了栈的深度，比如递归调用。
    可使用-Xss去调整JVM栈的大小。

你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。

当出现了内存溢出，你怎么排错。
    首先分析是什么类型的内存溢出。
    是堆内存、栈内存、还是永久代（java 8移除）。
    堆内存溢出：
        java.lang.OutOfMemoryError: Java heap space
        年老代空间占满。
    堆栈溢出：
        java.lang.StackOverflowError
        一般就是递归没返回，或者循环调用造成。
    线程堆栈满：
        Fatal: Stack size too small
        java中一个线程的空间大小有限制，当线程空间满了以后，会出现异常。
        增加线程栈大小，-Xss。
    系统内存被占满：
        java.lang.OutOfMemoryError: unable to create new native thread
        操作系统没有足够的资源来产生这个线程。
        减小单个线程内存大小：-Xss
    持久代：
        java.lang.OutOfMemoryError: PermGen space
        持久代被占满，无法为新的class分配存储空间而引发的异常。java反射容易出现该异常，主要原因是大量动态反射生成的类被不断加载。
        增加持久代的空间 -XX:MaxPermSize=100M。
JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。
你们线上应用的JVM参数有哪些。
g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择。
怎么打出线程栈信息。
    ps -ef | grep tomcat 找出java进程
    top -Hp 21251 找出进程21251中最耗费cpu的线程
    jstack 21251 | grep 5431 输出进程21251的堆栈信息，然后根据线程ID的十六进制grep.
请解释如下jvm参数的含义：
-server -Xms512m -Xmx512m -Xss1024K
-XX:PermSize=256m -XX:MaxPermSize=512m -
XX:MaxTenuringThreshold=20XX:CMSInitiatingOccupancyFraction=80 -
XX:+UseCMSInitiatingOccupancyOnly。

简单讲讲tomcat结构，以及其类加载器流程，线程模型等。

tomcat如何调优，涉及哪些参数。

GC回收算法, 及实现原理?
    标记-清除：
        标记所有可达对象，清除其余未被标记的对象。
    复制算法（新生代GC）：
        将原有的内存空间分两块，每次只是用其中一块，在GC时，将正在使用的内存中的存活对象复制到未使用的内存中，然后清除其余。
    标记-整理（老年代GC）：
        标记可达对象，将可达对象压缩到内存的一端，之后，清理边界外的空间。
    分代收集算法：
        生命周期短、少量存活的适合复制算法。
        生命周期长、大量存活的时候标-整理算法。

jvm 运行时的数据区
    方法区、堆、程序计数器、虚拟机栈、本地方法栈。

20、描述Java内存模型?
    JVM内存分为虚拟机栈、堆、方法区、程序计数器、本地方法栈5个部分。
    方法区：
        即永久代，线程共享，存储已被虚拟机加载的类信息、常量、静态变量。
        永久代大小有限制，如果加载的类太多，很可能会导致内存溢出，即java.lang.OutOfMemoryError: PermGen。
        java 8中永久代被移出，方法区移至Metespace（元空间，本地堆内存），字符串常量移到java堆。
        如果Metaspace的空间占用达到了设定的最大值，那么就会触发GC来收集死亡对象和类的加载器。
    
    程序计数器：
        线程私有，保存指令的偏移地址，字节码解释器根据该地址来执行指令。
        生命周期随线程。
    
    虚拟机栈：
        线程私有，生命周期随线程。
        每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表（平时所说的栈）、操作数栈、动态链接、方法出口等。
        每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
        局部变量表存放了编译器可预知的各种基本数据类型、对象引用、eturnAddress类型（指向了一条字节码指令的地址）。

    本地方法栈：
        　本地方法栈与虚拟机栈所发挥的作用非常相似，他们之间的区别不过是虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则为虚拟机中使用到的native方法服务
21、java中垃圾收集的方法有哪些?

22、如和判断一个对象是否存活?(或者GC对象的判定方法)?
    是否可达。


27、分别写出堆内存溢出与栈内存溢出的程序?

28、Java 8 内存模型进行了哪些改进?
    

29、简述java内存分配与回收策率以及Minor GC和Major GC?
    Minor GC：
        eden区满时，触发Minor GC，即申请一个对象时，发现eden区不够用时，则触发一次Minor GC。
        eden : survivor from : survivor to = 8 : 1 : 1

    Major GC/Full GC:
        老年代GC。
        大对象无法在eden分配则直接进入老年代。
        老年代空间不足则触发GC。

4、JVM内存管理，GC算法，HotSpot里面的垃圾回收器、类加载 
    JVM内存主要分为五个区，哪些是线程共享的，哪些是线程独享的，每个区存放什么。
    GC方面：怎么判断哪些对象需要被GC，GC的方法，Minor GC与Full GC。HotSpot GC算法以及7种垃圾回收期，主要讲了CMS和G1收集器。
    -Xms：
    -Xmx：
    -Xmn：
    -Xss:规定了每个线程堆栈的大小。
    -XX:NewSize，
    -XX:MaxNewSize，
    -XX:PermSize,
    -XX:MaxPermSize	
    -XX:NewRatio，
    -XX:+UseConcMarkSweepGC，
    -XX:+PrintGC是什么含义？

如何打印GC日志，如何分析？
    -XX:+PrintGCDetails 
    -XX:+PrintGCDateStamps 
    -Xloggc:/home/GCEASY/gc-%t.log
    在GC文件后缀加上时间戳，当JVM重启以后，会生成新的日志文件。
    %t会给文件名添加时间戳后缀，格式是YYYY-MM-DD_HH-MM-SS。

JVM内存区域划分？JDK 7 或JDK 8


Java中什么是堆、什么是栈，他们用来存储什么数据？
    堆：
        虚拟机管理并被所有线程所共享的一块内存区域，目的是存放对象实例，几乎所有的对象实例都在这里分配内存。
        几乎所有的对象实例和数组都在堆上分配。
        栈中存放基本数据类型和对象的引用。

如何导出Java程序的堆栈？
    jstack命令，用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合。
    jstack 5661 显示java 进程5661的堆栈信息
    jstack pid > stack.txt 输出到文件

堆的分代有哪些？为什么要分代？
    为什么要分代：
        因为不同的对象的生命周期是不一样的。
    分代：
        年轻代：
            Eden和Survivor。回收内存被称为Minor GC。
        老年代：
            回收内存被称为Major GC。
            Full GC是清理整个堆空间。
        新创建的对象都会被分配到Eden区（一些大对象特殊处理），经过一次Minor GC之后会被移到Survivor，
        在Survivor区每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代。
    年轻代和老年代的内存回收算法完全不同：
        因为年轻代存活的对象少，采用复制算法（复制的少）将存活对象移到survivor区，更高效；
        老年代，存活对象的变动很少，采用标记清除压缩算法更合适。
    
    有关年轻代的JVM参数：
        1)-XX:NewSize和-XX:MaxNewSize
        用于设置年轻代的大小，建议设为整个堆大小的1/3或者1/4,两个值设为一样大。

        2)-XX:SurvivorRatio
        用于设置Eden和其中一个Survivor的比值，这个值也比较重要。

        3)-XX:+PrintTenuringDistribution
        这个参数用于显示每次Minor GC时Survivor区中各个年龄段的对象的大小。

        4).-XX:InitialTenuringThreshol和-XX:MaxTenuringThreshold
        用于设置晋升到老年代的对象年龄的最小值和最大值，每个对象在坚持过一次Minor GC之后，年龄就加1。

JDK 7 以前是如何进行GC的、JVM 中的YGC和FGC发生的具体场景？
    

Java有哪些GC的算法，有哪些GC回收器？


哪里、什么时候，堆或栈会发生溢出？说说内存溢出可能原因和解决方案。
    启动参数内存值设定的大小。
    内存中加载的数据太多。
    不再使用的对象，未置空。

    检查：
        是否有sql一次性取大量数据，时候一次性xml大量数据。
        是否有死循环或递归调用。
        List、Map等集合对象是否有使用完后，未清除的问题。集合会始终存有对象的引用。

    -Xms 为jvm启动时分配的内存，比如-Xms200m，表示分配200M
    -Xmx 为jvm运行过程中分配的最大内存，比如-Xms500m，表示jvm进程最多只能够占用500M内存
    -Xss 为jvm启动的每个线程分配的内存大小，默认JDK1.4中是256K，JDK1.5+中是1M

什么是GC Roots, safepoint，saferegion？
    safePoint:
        所有的垃圾收集器，在可达对象的标记阶段都必须停止所有java执行线程，以保证引用状态不会发生变化，safepoint是程序中的某些位置，
        线程执行到这些位置时，线程中的某些状态是确定的。线程在safepoint停顿，虚拟机进行GC。
    safeRegion:
        代码中的一块区域或线程的转改，在safeRegion中，线程执行与否不会影响对象引用的状态，线程进入safeRegion会给自己加标记，告诉虚拟机
        可以进行GC，线程离开safeRegion前会询问虚拟机GC是否完成。 

jvm优化方法：
    1、根据垃圾收集器的特征，选择适合自己业务的垃圾收集器。
    2、观察目前的垃圾回收情况，分析出老年代和年轻代的回收情况，适当的去调整内存大小和XX:SurvivorRatio的比例。
    3、不断去调整jvm内存比例，老年代、年轻代、持久代的比例，直到测试出一个比较满意的值。
    总结：
        总的来说不是仅仅加大内存就可以解决的。需要总和业务特征和GC时间。
        减少新生代大小可以缩短新生代GC停顿时间，但频率会很高。而且会有更多的垃圾进入到老年代，如果增加新生代大小又会导致回收的时间和复制的时间变久，
        所以需要折中。
        针对大部分数据都在Eden区域被回收，并且几乎没有对象在survivor区域死亡的场景，完全可以减少 XX:MaxTenuringThreshold 这个参数，让数据提早进入到老年代。
    https://wangkang007.gitbooks.io/jvm/content/4jvmdiao_you.html
